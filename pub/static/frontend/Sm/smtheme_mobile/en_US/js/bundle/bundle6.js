require.config({"config": {
        "jsbuild":{"Sm_DegreeView/js/spritespin.js":"(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n        typeof define === 'function' && define.amd ? define(['exports'], factory) :\n            (factory((global.SpriteSpin = {})));\n}(this, (function (exports) { 'use strict';\n\n    /**\n     * @internal\n     */\n    var Api = /** @class */ (function () {\n        function Api(data) {\n            this.data = data;\n        }\n        return Api;\n    }());\n    /**\n     * Adds methods to the SpriteSpin api\n     *\n     * @public\n     */\n    function extendApi(methods) {\n        var api = Api.prototype;\n        for (var key in methods) {\n            if (methods.hasOwnProperty(key)) {\n                if (api[key]) {\n                    throw new Error('API method is already defined: ' + key);\n                }\n                else {\n                    api[key] = methods[key];\n                }\n            }\n        }\n        return api;\n    }\n\n    var $$1 = window.jQuery || window.$;\n\n    function getCursorPosition(event) {\n        var touches = event.touches;\n        var source = event;\n        // jQuery Event normalization does not preserve the 'event.touches'\n        // try to grab touches from the original event\n        if (event.touches === undefined && event.originalEvent !== undefined) {\n            touches = event.originalEvent.touches;\n        }\n        // get current touch or mouse position\n        if (touches !== undefined && touches.length > 0) {\n            source = touches[0];\n        }\n        return {\n            x: source.clientX || 0,\n            y: source.clientY || 0\n        };\n    }\n\n    var canvas;\n    var context;\n    function detectionContext() {\n        if (context) {\n            return context;\n        }\n        if (!canvas) {\n            canvas = document.createElement('canvas');\n        }\n        if (!canvas || !canvas.getContext) {\n            return null;\n        }\n        context = canvas.getContext('2d');\n        return context;\n    }\n    /**\n     * Idea taken from https://github.com/stomita/ios-imagefile-megapixel\n     * Detects whether the image has been sub sampled by the browser and does not have its original dimensions.\n     * This method unfortunately does not work for images that have transparent background.\n     */\n    function detectSubsampling(img, width, height) {\n        if (!detectionContext()) {\n            return false;\n        }\n        // sub sampling happens on images above 1 megapixel\n        if (width * height <= 1024 * 1024) {\n            return false;\n        }\n        // set canvas to 1x1 pixel size and fill it with magenta color\n        canvas.width = canvas.height = 1;\n        context.fillStyle = '#FF00FF';\n        context.fillRect(0, 0, 1, 1);\n        // render the image with a negative offset to the left so that it would\n        // fill the canvas pixel with the top right pixel of the image.\n        context.drawImage(img, -width + 1, 0);\n        // check color value to confirm image is covering edge pixel or not.\n        // if color still magenta, the image is assumed to be sub sampled.\n        try {\n            var dat = context.getImageData(0, 0, 1, 1).data;\n            return (dat[0] === 255) && (dat[1] === 0) && (dat[2] === 255);\n        }\n        catch (err) {\n            // avoids cross origin exception for chrome when code runs without a server\n            return false;\n        }\n    }\n\n    /**\n     *\n     */\n    function getOuterSize(data) {\n        var width = Math.floor(data.width || data.frameWidth || data.target.innerWidth());\n        var height = Math.floor(data.height || data.frameHeight || data.target.innerHeight());\n        return {\n            aspect: width / height,\n            height: height,\n            width: width\n        };\n    }\n    function getComputedSize(data) {\n        var size = getOuterSize(data);\n        if (typeof window.getComputedStyle !== 'function') {\n            return size;\n        }\n        var style = window.getComputedStyle(data.target[0]);\n        if (!style.width) {\n            return size;\n        }\n        size.width = Math.floor(Number(style.width.replace('px', '')));\n        size.height = Math.floor(size.width / size.aspect);\n        return size;\n    }\n    /**\n     *\n     */\n    function getInnerSize(data) {\n        var width = Math.floor(data.frameWidth || data.width || data.target.innerWidth());\n        var height = Math.floor(data.frameHeight || data.height || data.target.innerHeight());\n        return {\n            aspect: width / height,\n            height: height,\n            width: width\n        };\n    }\n    /**\n     *\n     */\n    function getInnerLayout(mode, inner, outer) {\n        // get mode\n        var isFit = mode === 'fit';\n        var isFill = mode === 'fill';\n        var isMatch = mode === 'stretch';\n        // resulting layout\n        var layout = {\n            width: '100%',\n            height: '100%',\n            top: 0,\n            left: 0,\n            bottom: 0,\n            right: 0,\n            position: 'absolute',\n            overflow: 'hidden'\n        };\n        // no calculation here\n        if (!mode || isMatch) {\n            return layout;\n        }\n        // get size and aspect\n        var aspectIsGreater = inner.aspect >= outer.aspect;\n        // mode == original\n        var width = inner.width;\n        var height = inner.height;\n        // keep aspect ratio but fit/fill into container\n        if (isFit && aspectIsGreater || isFill && !aspectIsGreater) {\n            width = outer.width;\n            height = outer.width / inner.aspect;\n        }\n        if (isFill && aspectIsGreater || isFit && !aspectIsGreater) {\n            height = outer.height;\n            width = outer.height * inner.aspect;\n        }\n        // floor the numbers\n        width = Math.floor(width);\n        height = Math.floor(height);\n        // position in center\n        layout.width = width;\n        layout.height = height;\n        layout.top = Math.floor((outer.height - height) / 2);\n        layout.left = Math.floor((outer.width - width) / 2);\n        layout.right = layout.left;\n        layout.bottom = layout.top;\n        return layout;\n    }\n\n    var img;\n    /**\n     * gets the original width and height of an image element\n     */\n    function naturalSize(image) {\n        // for browsers that support naturalWidth and naturalHeight properties\n        if (image.naturalWidth) {\n            return {\n                height: image.naturalHeight,\n                width: image.naturalWidth\n            };\n        }\n        // browsers that do not support naturalWidth and naturalHeight properties have to fall back to the width and\n        // height properties. However, the image might have a css style applied so width and height would return the\n        // css size. To avoid thet create a new Image object that is free of css rules and grab width and height\n        // properties\n        //\n        // assume that the src has already been downloaded, so no onload callback is needed.\n        img = img || new Image();\n        img.src = image.src;\n        return {\n            height: img.height,\n            width: img.width\n        };\n    }\n\n    /**\n     * Measures the image frames that are used in the given data object\n     */\n    function measure(images, options) {\n        if (images.length === 1) {\n            return [measureSheet(images[0], options)];\n        }\n        else if (options.framesX && options.framesY) {\n            return measureMutipleSheets(images, options);\n        }\n        else {\n            return measureFrames(images, options);\n        }\n    }\n    function measureSheet(image, options) {\n        var result = { id: 0, sprites: [] };\n        measureImage(image, options, result);\n        var frames = options.frames;\n        var framesX = Number(options.framesX) || frames;\n        var framesY = Math.ceil(frames / framesX);\n        var frameWidth = Math.floor(result.width / framesX);\n        var frameHeight = Math.floor(result.height / framesY);\n        var divisor = result.isSubsampled ? 2 : 1;\n        for (var i = 0; i < frames; i++) {\n            var x = (i % framesX) * frameWidth;\n            var y = Math.floor(i / framesX) * frameHeight;\n            result.sprites.push({\n                id: i,\n                x: x, y: y,\n                width: frameWidth,\n                height: frameHeight,\n                sampledX: x / divisor,\n                sampledY: y / divisor,\n                sampledWidth: frameWidth / divisor,\n                sampledHeight: frameHeight / divisor\n            });\n        }\n        return result;\n    }\n    function measureFrames(images, options) {\n        var result = [];\n        for (var id = 0; id < images.length; id++) {\n            // TODO: optimize\n            // dont measure images with same size twice\n            var sheet = measureSheet(images[id], { frames: 1, framesX: 1, detectSubsampling: options.detectSubsampling });\n            sheet.id = id;\n            result.push(sheet);\n        }\n        return result;\n    }\n    function measureMutipleSheets(images, options) {\n        var result = [];\n        for (var id = 0; id < images.length; id++) {\n            // TODO: optimize\n            // dont measure images with same size twice\n            var sheet = measureSheet(images[id], {\n                frames: undefined,\n                framesX: options.framesX,\n                framesY: options.framesY,\n                detectSubsampling: options.detectSubsampling\n            });\n            sheet.id = id;\n            result.push(sheet);\n        }\n        return result;\n    }\n    function measureImage(image, options, result) {\n        var size = naturalSize(image);\n        result.isSubsampled = options.detectSubsampling && detectSubsampling(image, size.width, size.height);\n        result.width = size.width;\n        result.height = size.height;\n        result.sampledWidth = size.width / (result.isSubsampled ? 2 : 1);\n        result.sampledHeight = size.height / (result.isSubsampled ? 2 : 1);\n        return result;\n    }\n    function findSpecs(metrics, frames, frame, lane) {\n        var spriteId = lane * frames + frame;\n        var sheetId = 0;\n        var sprite = null;\n        var sheet = null;\n        while (true) {\n            sheet = metrics[sheetId];\n            if (!sheet) {\n                break;\n            }\n            if (spriteId >= sheet.sprites.length) {\n                spriteId -= sheet.sprites.length;\n                sheetId++;\n                continue;\n            }\n            sprite = sheet.sprites[spriteId];\n            break;\n        }\n        return { sprite: sprite, sheet: sheet };\n    }\n\n    function indexOf(element, arr) {\n        for (var i = 0; i < arr.length; i++) {\n            if (arr[i] === element) {\n                return i;\n            }\n        }\n    }\n    function noop() {\n        //\n    }\n    function preload(opts) {\n        var src;\n        var input = opts.source;\n        src = typeof input === 'string' ? [input] : input;\n        // const src: string[] =  ? [opts.source] : opts.source\n        var images = [];\n        var targetCount = (opts.preloadCount || src.length);\n        var onInitiated = opts.initiated || noop;\n        var onProgress = opts.progress || noop;\n        var onComplete = opts.complete || noop;\n        var count = 0;\n        var completed = false;\n        var firstLoaded = false;\n        var tick = function () {\n            count += 1;\n            onProgress({\n                index: indexOf(this, images),\n                loaded: count,\n                total: src.length,\n                percent: Math.round((count / src.length) * 100)\n            });\n            firstLoaded = firstLoaded || (this === images[0]);\n            if (firstLoaded && !completed && (count >= targetCount)) {\n                completed = true;\n                onComplete(images);\n            }\n        };\n        for (var _i = 0, src_1 = src; _i < src_1.length; _i++) {\n            var url = src_1[_i];\n            var img = new Image();\n            // push result\n            images.push(img);\n            // bind logic, dont care about abort/errors\n            img.onload = img.onabort = img.onerror = tick;\n            // begin load\n            img.src = url;\n        }\n        onInitiated(images);\n    }\n\n    function padNumber(num, length, pad) {\n        var result = String(num);\n        while (result.length < length) {\n            result = String(pad) + result;\n        }\n        return result;\n    }\n    /**\n     * Generates an array of source strings\n     *\n     * @remarks\n     * Takes a template string and generates an array of strings by interpolating {lane} and {frame} placeholders.\n     *\n     * ```\n     * sourceArray('http://example.com/image_{frame}.jpg, { frame: [1, 3], digits: 2 })\n     * // gives:\n     * // [ 'http://example.com/image_01.jpg', 'http://example.com/image_02.jpg', 'http://example.com/image_03.jpg' ]\n     *\n     * sourceArray('http://example.com/image_FRAME.jpg, { frame: [1, 3], digits: 2, framePlacer: 'FRAME' })\n     * // gives:\n     * // [ 'http://example.com/image_01.jpg', 'http://example.com/image_02.jpg', 'http://example.com/image_03.jpg' ]\n     * ```\n     *\n     * @param template - The template string\n     * @param opts - Interpolation options\n     *\n     * @public\n     */\n    function sourceArray(template, opts) {\n        var digits = opts.digits || 2;\n        var lPlacer = opts.lanePlacer || '{lane}';\n        var fPlacer = opts.framePlacer || '{frame}';\n        var fStart = 0;\n        var fEnd = 0;\n        if (opts.frame) {\n            fStart = opts.frame[0];\n            fEnd = opts.frame[1];\n        }\n        var lStart = 0;\n        var lEnd = 0;\n        if (opts.lane) {\n            lStart = opts.lane[0];\n            lEnd = opts.lane[1];\n        }\n        var result = [];\n        for (var lane = lStart; lane <= lEnd; lane += 1) {\n            for (var frame = fStart; frame <= fEnd; frame += 1) {\n                result.push(template\n                    .replace(lPlacer, padNumber(lane, digits, '0'))\n                    .replace(fPlacer, padNumber(frame, digits, '0')));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * The namespace that is used to bind functions to DOM events and store the data object\n     */\n    var namespace = 'spritespin';\n    /**\n     * Event names that are recognized by SpriteSpin. A module can implement any of these and they will be bound\n     * to the target element on which the plugin is called.\n     */\n    var eventNames = [\n        'mousedown',\n        'mousemove',\n        'mouseup',\n        'mouseenter',\n        'mouseover',\n        'mouseleave',\n        'mousewheel',\n        'wheel',\n        'click',\n        'dblclick',\n        'touchstart',\n        'touchmove',\n        'touchend',\n        'touchcancel',\n        'selectstart',\n        'gesturestart',\n        'gesturechange',\n        'gestureend'\n    ];\n    /**\n     *\n     */\n    var callbackNames = [\n        'onInit',\n        'onProgress',\n        'onLoad',\n        'onFrameChanged',\n        'onFrame',\n        'onDraw',\n        'onComplete',\n        'onDestroy'\n    ];\n    /**\n     * Names of events for that the default behavior should be prevented.\n     */\n    var eventsToPrevent = [\n        'dragstart'\n    ];\n    /**\n     * Default set of SpriteSpin options. This also represents the majority of data attributes that are used during the\n     * lifetime of a SpriteSpin instance. The data is stored inside the target DOM element on which the plugin is called.\n     */\n    var defaults = {\n        source: undefined,\n        width: undefined,\n        height: undefined,\n        frames: undefined,\n        framesX: undefined,\n        lanes: 1,\n        sizeMode: undefined,\n        renderer: 'canvas',\n        lane: 0,\n        frame: 0,\n        frameTime: 40,\n        animate: true,\n        retainAnimate: false,\n        reverse: false,\n        loop: true,\n        stopFrame: 0,\n        wrap: true,\n        wrapLane: false,\n        sense: 1,\n        senseLane: undefined,\n        orientation: 'horizontal',\n        detectSubsampling: true,\n        preloadCount: undefined,\n        touchScrollTimer: [200, 1500],\n        responsive: undefined,\n        plugins: undefined\n    };\n\n    function noop$1() {\n        // noop\n    }\n    function wrapConsole(type) {\n        return console && console[type] ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return console.log.apply(console, args);\n        } : noop$1;\n    }\n    var log = wrapConsole('log');\n    var warn = wrapConsole('warn');\n    var error = wrapConsole('error');\n    function toArray(value) {\n        return Array.isArray(value) ? value : [value];\n    }\n    /**\n     * clamps the given value by the given min and max values\n     */\n    function clamp(value, min, max) {\n        return (value > max ? max : (value < min ? min : value));\n    }\n    /**\n     *\n     */\n    function wrap(value, min, max, size) {\n        while (value > max) {\n            value -= size;\n        }\n        while (value < min) {\n            value += size;\n        }\n        return value;\n    }\n    /**\n     * prevents default action on the given event\n     */\n    function prevent(e) {\n        e.preventDefault();\n        return false;\n    }\n    /**\n     * Binds on the given target and event the given function.\n     * The SpriteSpin namespace is attached to the event name\n     */\n    function bind(target, event, func) {\n        if (func) {\n            target.bind(event + '.' + namespace, function (e) {\n                func.apply(target, [e, target.spritespin('data')]);\n            });\n        }\n    }\n    /**\n     * Unbinds all SpriteSpin events from given target element\n     */\n    function unbind(target) {\n        target.unbind('.' + namespace);\n    }\n    /**\n     * Checks if given object is a function\n     */\n    function isFunction(fn) {\n        return typeof fn === 'function';\n    }\n    function pixelRatio(context) {\n        var devicePixelRatio = window.devicePixelRatio || 1;\n        var backingStoreRatio = context.webkitBackingStorePixelRatio ||\n            context.mozBackingStorePixelRatio ||\n            context.msBackingStorePixelRatio ||\n            context.oBackingStorePixelRatio ||\n            context.backingStorePixelRatio || 1;\n        return devicePixelRatio / backingStoreRatio;\n    }\n\n\n\n    var _Utils = Object.freeze({\n        $: $$1,\n        getCursorPosition: getCursorPosition,\n        detectSubsampling: detectSubsampling,\n        getOuterSize: getOuterSize,\n        getComputedSize: getComputedSize,\n        getInnerSize: getInnerSize,\n        getInnerLayout: getInnerLayout,\n        measure: measure,\n        findSpecs: findSpecs,\n        naturalSize: naturalSize,\n        preload: preload,\n        sourceArray: sourceArray,\n        noop: noop$1,\n        log: log,\n        warn: warn,\n        error: error,\n        toArray: toArray,\n        clamp: clamp,\n        wrap: wrap,\n        prevent: prevent,\n        bind: bind,\n        unbind: unbind,\n        isFunction: isFunction,\n        pixelRatio: pixelRatio\n    });\n\n    /**\n     * Applies css attributes to layout the SpriteSpin containers.\n     *\n     * @internal\n     */\n    function applyLayout(data) {\n        // disable selection\n        data.target\n            .attr('unselectable', 'on')\n            .css({\n                width: '',\n                height: '',\n                '-ms-user-select': 'none',\n                '-moz-user-select': 'none',\n                '-khtml-user-select': 'none',\n                '-webkit-user-select': 'none',\n                'user-select': 'none'\n            });\n        var size = data.responsive ? getComputedSize(data) : getOuterSize(data);\n        var layout = getInnerLayout(data.sizeMode, getInnerSize(data), size);\n        // apply layout on target\n        data.target.css({\n            width: size.width,\n            height: size.height,\n            position: 'relative',\n            overflow: 'hidden'\n        });\n        // apply layout on stage\n        data.stage\n            .css(layout)\n            .hide();\n        if (!data.canvas) {\n            return;\n        }\n        // apply layout on canvas\n        data.canvas.css(layout).hide();\n        // apply pixel ratio on canvas\n        data.canvasRatio = data.canvasRatio || pixelRatio(data.context);\n        if (typeof layout.width === 'number' && typeof layout.height === 'number') {\n            data.canvas[0].width = (layout.width * data.canvasRatio) || size.width;\n            data.canvas[0].height = (layout.height * data.canvasRatio) || size.height;\n        }\n        else {\n            data.canvas[0].width = (size.width * data.canvasRatio);\n            data.canvas[0].height = (size.height * data.canvasRatio);\n        }\n        // width and height must be set before calling scale\n        data.context.scale(data.canvasRatio, data.canvasRatio);\n    }\n\n    /**\n     * Gets a state object by name.\n     * @internal\n     * @param data - The SpriteSpin instance data\n     * @param name - The name of the state object\n     */\n    function getState(data, name) {\n        data.state = data.state || {};\n        data.state[name] = data.state[name] || {};\n        return data.state[name];\n    }\n    /**\n     * Gets a plugin state object by name.\n     *\n     * @remarks\n     * Plugins should use this method to get or create a state object where they can\n     * store any instance variables.\n     *\n     * @public\n     * @param data - The SpriteSpin instance data\n     * @param name - The name of the plugin\n     */\n    function getPluginState(data, name) {\n        var state = getState(data, 'plugin');\n        state[name] = state[name] || {};\n        return state[name];\n    }\n    /**\n     * Checks whether a flag is set. See {@link flag}.\n     *\n     * @public\n     * @param data - The SpriteSpin instance data\n     * @param key - The name of the flag\n     */\n    function is(data, key) {\n        return !!getState(data, 'flags')[key];\n    }\n    /**\n     * Sets a flag value. See {@link is}.\n     *\n     * @public\n     * @param data - The SpriteSpin instance data\n     * @param key - The name of the flag\n     * @param value - The value to set\n     */\n    function flag(data, key, value) {\n        getState(data, 'flags')[key] = !!value;\n    }\n\n    /**\n     * Gets the playback state\n     *\n     * @public\n     * @param data - The SpriteSpin instance data\n     */\n    function getPlaybackState(data) {\n        return getState(data, 'playback');\n    }\n    function updateLane(data, lane) {\n        data.lane = data.wrapLane\n            ? wrap(lane, 0, data.lanes - 1, data.lanes)\n            : clamp(lane, 0, data.lanes - 1);\n    }\n    function updateAnimationFrame(data) {\n        data.frame += (data.reverse ? -1 : 1);\n        // wrap the frame value to fit in range [0, data.frames)\n        data.frame = wrap(data.frame, 0, data.frames - 1, data.frames);\n        // stop animation if loop is disabled and the stopFrame is reached\n        if (!data.loop && (data.frame === data.stopFrame)) {\n            stopAnimation(data);\n        }\n    }\n    function updateInputFrame(data, frame) {\n        data.frame = Number(frame);\n        data.frame = data.wrap\n            ? wrap(data.frame, 0, data.frames - 1, data.frames)\n            : clamp(data.frame, 0, data.frames - 1);\n    }\n    function updateAnimation(data) {\n        var state = getPlaybackState(data);\n        if (state.handler) {\n            updateBefore(data);\n            updateAnimationFrame(data);\n            updateAfter(data);\n        }\n    }\n    function updateBefore(data) {\n        var state = getPlaybackState(data);\n        state.lastFrame = data.frame;\n        state.lastLane = data.lane;\n    }\n    function updateAfter(data) {\n        var state = getPlaybackState(data);\n        if (state.lastFrame !== data.frame || state.lastLane !== data.lane) {\n            data.target.trigger('onFrameChanged.' + namespace, data);\n        }\n        data.target.trigger('onFrame.' + namespace, data);\n        data.target.trigger('onDraw.' + namespace, data);\n    }\n    /**\n     * Updates the frame or lane number of the SpriteSpin data.\n     *\n     * @public\n     * @param data - The SpriteSpin instance data\n     * @param frame - The frame number to set\n     * @param lane - The lane number to set\n     */\n    function updateFrame(data, frame, lane) {\n        updateBefore(data);\n        if (frame != null) {\n            updateInputFrame(data, frame);\n        }\n        if (lane != null) {\n            updateLane(data, lane);\n        }\n        updateAfter(data);\n    }\n    /**\n     * Stops the running animation.\n     *\n     * @public\n     * @param data - The SpriteSpin instance data\n     */\n    function stopAnimation(data) {\n        data.animate = false;\n        var state = getPlaybackState(data);\n        if (state.handler != null) {\n            window.clearInterval(state.handler);\n            state.handler = null;\n        }\n    }\n    /**\n     * Starts animation playback if needed.\n     *\n     * @remarks\n     * Starts animation playback if `animate` property is `true` and the animation is not yet running.\n     *\n     * @public\n     * @param data - The SpriteSpin instance data\n     */\n    function applyAnimation(data) {\n        var state = getPlaybackState(data);\n        if (state.handler && (!data.animate || state.frameTime !== data.frameTime)) {\n            stopAnimation(data);\n        }\n        if (data.animate && !state.handler) {\n            state.frameTime = data.frameTime;\n            state.handler = window.setInterval(function () { return updateAnimation(data); }, state.frameTime);\n        }\n    }\n    /**\n     * Starts the animation playback\n     *\n     * @remarks\n     * Starts the animation playback and also sets the `animate` property to `true`\n     *\n     * @public\n     * @param data - The SpriteSpin instance data\n     */\n    function startAnimation(data) {\n        data.animate = true;\n        applyAnimation(data);\n    }\n\n    var plugins = {};\n    /**\n     * Registers a plugin.\n     *\n     * @remarks\n     * Use this to add custom Rendering or Updating modules that can be addressed with the 'module' option.\n     *\n     * @public\n     * @param name - The name of the plugin\n     * @param plugin - The plugin implementation\n     */\n    function registerPlugin(name, plugin) {\n        if (plugins[name]) {\n            error(\"Plugin name \\\"\" + name + \"\\\" is already taken\");\n            return;\n        }\n        plugin = plugin || {};\n        plugins[name] = plugin;\n        return plugin;\n    }\n    /**\n     * Registers a plugin.\n     *\n     * @public\n     * @deprecated Use {@link registerPlugin} instead\n     * @param name - The name of the plugin\n     * @param plugin - The plugin implementation\n     */\n    function registerModule(name, plugin) {\n        warn('\"registerModule\" is deprecated, use \"registerPlugin\" instead');\n        registerPlugin(name, plugin);\n    }\n    /**\n     * Gets an active plugin by name\n     *\n     * @internal\n     * @param name - The name of the plugin\n     */\n    function getPlugin(name) {\n        return plugins[name];\n    }\n    /**\n     * Replaces module names on given SpriteSpin data and replaces them with actual implementations.\n     * @internal\n     */\n    function applyPlugins(data) {\n        fixPlugins(data);\n        for (var i = 0; i < data.plugins.length; i += 1) {\n            var name_1 = data.plugins[i];\n            if (typeof name_1 !== 'string') {\n                continue;\n            }\n            var plugin = getPlugin(name_1);\n            if (!plugin) {\n                error('No plugin found with name ' + name_1);\n                continue;\n            }\n            data.plugins[i] = plugin;\n        }\n    }\n    function fixPlugins(data) {\n        // tslint:disable no-string-literal\n        if (data['mods']) {\n            warn('\"mods\" option is deprecated, use \"plugins\" instead');\n            data.plugins = data['mods'];\n            delete data['mods'];\n        }\n        if (data['behavior']) {\n            warn('\"behavior\" option is deprecated, use \"plugins\" instead');\n            data.plugins.push(data['behavior']);\n            delete data['behavior'];\n        }\n        if (data['module']) {\n            warn('\"module\" option is deprecated, use \"plugins\" instead');\n            data.plugins.push(data['module']);\n            delete data['module'];\n        }\n    }\n\n    var $$2 = $$1;\n    var counter = 0;\n    /**\n     * Collection of all SpriteSpin instances\n     */\n    var instances = {};\n    function pushInstance(data) {\n        counter += 1;\n        data.id = String(counter);\n        instances[data.id] = data;\n    }\n    function popInstance(data) {\n        delete instances[data.id];\n    }\n    function eachInstance(cb) {\n        for (var id in instances) {\n            if (instances.hasOwnProperty(id)) {\n                cb(instances[id]);\n            }\n        }\n    }\n    var lazyinit = function () {\n        // replace function with a noop\n        // this logic must run only once\n        lazyinit = function () { };\n        function onEvent(eventName, e) {\n            eachInstance(function (data) {\n                for (var _i = 0, _a = data.plugins; _i < _a.length; _i++) {\n                    var module_1 = _a[_i];\n                    if (typeof module_1[eventName] === 'function') {\n                        module_1[eventName].apply(data.target, [e, data]);\n                    }\n                }\n            });\n        }\n        function onResize() {\n            eachInstance(function (data) {\n                if (data.responsive) {\n                    boot(data);\n                }\n            });\n        }\n        var _loop_1 = function (eventName) {\n            $$2(window.document).bind(eventName + '.' + namespace, function (e) {\n                onEvent('document' + eventName, e);\n            });\n        };\n        for (var _i = 0, eventNames_1 = eventNames; _i < eventNames_1.length; _i++) {\n            var eventName = eventNames_1[_i];\n            _loop_1(eventName);\n        }\n        var resizeTimeout = null;\n        $$2(window).on('resize', function () {\n            window.clearTimeout(resizeTimeout);\n            resizeTimeout = window.setTimeout(onResize, 100);\n        });\n    };\n    /**\n     * (re)binds all spritespin events on the target element\n     *\n     * @internal\n     */\n    function applyEvents(data) {\n        var target = data.target;\n        // Clear all SpriteSpin events on the target element\n        unbind(target);\n        // disable all default browser behavior on the following events\n        // mainly prevents image drag operation\n        for (var _i = 0, eventsToPrevent_1 = eventsToPrevent; _i < eventsToPrevent_1.length; _i++) {\n            var eName = eventsToPrevent_1[_i];\n            bind(target, eName, prevent);\n        }\n        // Bind module functions to SpriteSpin events\n        for (var _a = 0, _b = data.plugins; _a < _b.length; _a++) {\n            var plugin = _b[_a];\n            for (var _c = 0, eventNames_2 = eventNames; _c < eventNames_2.length; _c++) {\n                var eName = eventNames_2[_c];\n                bind(target, eName, plugin[eName]);\n            }\n            for (var _d = 0, callbackNames_1 = callbackNames; _d < callbackNames_1.length; _d++) {\n                var eName = callbackNames_1[_d];\n                bind(target, eName, plugin[eName]);\n            }\n        }\n        // bind auto start function to load event.\n        bind(target, 'onLoad', function (e, d) {\n            applyAnimation(d);\n        });\n        // bind all user events that have been passed on initialization\n        for (var _e = 0, callbackNames_2 = callbackNames; _e < callbackNames_2.length; _e++) {\n            var eName = callbackNames_2[_e];\n            bind(target, eName, data[eName]);\n        }\n    }\n    function applyMetrics(data) {\n        if (!data.images) {\n            data.metrics = [];\n        }\n        data.metrics = measure(data.images, data);\n        var spec = findSpecs(data.metrics, data.frames, 0, 0);\n        if (spec.sprite) {\n            // TODO: try to remove frameWidth/frameHeight\n            data.frameWidth = spec.sprite.width;\n            data.frameHeight = spec.sprite.height;\n        }\n    }\n    /**\n     * Runs the boot process.\n     *\n     * @remarks\n     * (re)initializes plugins, (re)initializes the layout, (re)binds events and loads source images.\n     *\n     * @internal\n     */\n    function boot(data) {\n        applyPlugins(data);\n        applyEvents(data);\n        applyLayout(data);\n        data.source = toArray(data.source);\n        data.loading = true;\n        data.target\n            .addClass('loading')\n            .trigger('onInit.' + namespace, data);\n        preload({\n            source: data.source,\n            preloadCount: data.preloadCount,\n            progress: function (progress) {\n                data.progress = progress;\n                data.target.trigger('onProgress.' + namespace, data);\n            },\n            complete: function (images) {\n                data.images = images;\n                data.loading = false;\n                data.frames = data.frames || images.length;\n                applyMetrics(data);\n                applyLayout(data);\n                data.stage.show();\n                data.target\n                    .removeClass('loading')\n                    .trigger('onLoad.' + namespace, data)\n                    .trigger('onFrame.' + namespace, data)\n                    .trigger('onDraw.' + namespace, data)\n                    .trigger('onComplete.' + namespace, data);\n            }\n        });\n    }\n    /**\n     * Creates a new SpriteSpin instance\n     *\n     * @public\n     */\n    function create(options) {\n        var _this = this;\n        var target = options.target;\n        // SpriteSpin is not initialized\n        // Create default settings object and extend with given options\n        var data = $$2.extend(true, {}, defaults, options);\n        // ensure source is set\n        data.source = data.source || [];\n        // ensure plugins are set\n        data.plugins = data.plugins || [\n            '360',\n            'drag'\n        ];\n        // if image tags are contained inside this DOM element\n        // use these images as the source files\n        target.find('img').each(function () {\n            if (!Array.isArray(data.source)) {\n                data.source = [];\n            }\n            data.source.push($$2(_this).attr('src'));\n        });\n        // build inner html\n        // <div>\n        //   <div class='spritespin-stage'></div>\n        //   <canvas class='spritespin-canvas'></canvas>\n        // </div>\n        target\n            .empty()\n            .addClass('spritespin-instance')\n            .append(\"<div class='spritespin-stage'></div>\");\n        // add the canvas element if canvas rendering is enabled and supported\n        if (data.renderer === 'canvas') {\n            var canvas = document.createElement('canvas');\n            if (!!(canvas.getContext && canvas.getContext('2d'))) {\n                data.canvas = $$2(canvas).addClass('spritespin-canvas');\n                data.context = canvas.getContext('2d');\n                target.append(data.canvas);\n                target.addClass('with-canvas');\n            }\n            else {\n                // fallback to image rendering mode\n                data.renderer = 'image';\n            }\n        }\n        // setup references to DOM elements\n        data.target = target;\n        data.stage = target.find('.spritespin-stage');\n        // store the data\n        target.data(namespace, data);\n        pushInstance(data);\n        return data;\n    }\n    /**\n     * Creates a new SpriteSpin instance, or updates an existing one\n     *\n     * @public\n     */\n    function createOrUpdate(options) {\n        lazyinit();\n        var data = options.target.data(namespace);\n        if (!data) {\n            data = create(options);\n        }\n        else {\n            $$2.extend(data, options);\n        }\n        boot(data);\n        return data;\n    }\n    /**\n     * Destroys the SpriteSpin instance\n     *\n     * @remarks\n     * - stops running animation\n     * - unbinds all events\n     * - deletes the data on the target element\n     *\n     * @public\n     */\n    function destroy(data) {\n        popInstance(data);\n        stopAnimation(data);\n        data.target\n            .trigger('onDestroy', data)\n            .html(null)\n            .attr('style', null)\n            .attr('unselectable', null)\n            .removeClass(['spritespin-instance', 'with-canvas']);\n        unbind(data.target);\n        data.target.removeData(namespace);\n    }\n\n    /**\n     * Gets the current input state\n     *\n     * @public\n     * @param data - The SpriteSpin instance data\n     */\n    function getInputState(data) {\n        return getState(data, 'input');\n    }\n    /**\n     * Updates the input state using a mous or touch event.\n     *\n     * @public\n     * @param e - The input event\n     * @param data - The SpriteSpin instance data\n     */\n    function updateInput(e, data) {\n        var cursor = getCursorPosition(e);\n        var state = getInputState(data);\n        // cache positions from previous frame\n        state.oldX = state.currentX;\n        state.oldY = state.currentY;\n        state.currentX = cursor.x;\n        state.currentY = cursor.y;\n        // Fix old position.\n        if (state.oldX === undefined || state.oldY === undefined) {\n            state.oldX = state.currentX;\n            state.oldY = state.currentY;\n        }\n        // Cache the initial click/touch position and store the frame number at which the click happened.\n        // Useful for different behavior implementations. This must be restored when the click/touch is released.\n        if (state.startX === undefined || state.startY === undefined) {\n            state.startX = state.currentX;\n            state.startY = state.currentY;\n            state.clickframe = data.frame;\n            state.clicklane = data.lane;\n        }\n        // Calculate the vector from start position to current pointer position.\n        state.dX = state.currentX - state.startX;\n        state.dY = state.currentY - state.startY;\n        // Calculate the vector from last frame position to current pointer position.\n        state.ddX = state.currentX - state.oldX;\n        state.ddY = state.currentY - state.oldY;\n        // Normalize vectors to range [-1:+1]\n        state.ndX = state.dX / data.target.innerWidth();\n        state.ndY = state.dY / data.target.innerHeight();\n        state.nddX = state.ddX / data.target.innerWidth();\n        state.nddY = state.ddY / data.target.innerHeight();\n    }\n    /**\n     * Resets the input state.\n     *\n     * @public\n     */\n    function resetInput(data) {\n        var input = getInputState(data);\n        input.startX = input.startY = undefined;\n        input.currentX = input.currentY = undefined;\n        input.oldX = input.oldY = undefined;\n        input.dX = input.dY = 0;\n        input.ddX = input.ddY = 0;\n        input.ndX = input.ndY = 0;\n        input.nddX = input.nddY = 0;\n    }\n\n    function extension(option, value) {\n        var $target = $$1(this);\n        if (option === 'data') {\n            return $target.data(namespace);\n        }\n        if (option === 'api') {\n            var data = $target.data(namespace);\n            data.api = data.api || new Api(data);\n            return data.api;\n        }\n        if (option === 'destroy') {\n            return $target.each(function () {\n                var data = $target.data(namespace);\n                if (data) {\n                    destroy(data);\n                }\n            });\n        }\n        if (arguments.length === 2 && typeof option === 'string') {\n            option = (_a = {}, _a[option] = value, _a);\n        }\n        if (typeof option === 'object') {\n            return createOrUpdate($$1.extend(true, { target: $target }, option)).target;\n        }\n        throw new Error('Invalid call to spritespin');\n        var _a;\n    }\n    $$1.fn[namespace] = extension;\n\n// tslint:disable:object-literal-shorthand\n// tslint:disable:only-arrow-functions\n    extendApi({\n        // Gets a value indicating whether the animation is currently running.\n        isPlaying: function () {\n            return getPlaybackState(this.data).handler != null;\n        },\n        // Gets a value indicating whether the animation looping is enabled.\n        isLooping: function () {\n            return this.data.loop;\n        },\n        // Starts/Stops the animation playback\n        toggleAnimation: function () {\n            if (this.isPlaying()) {\n                this.stopAnimation();\n            }\n            else {\n                this.startAnimation();\n            }\n        },\n        // Stops animation playback\n        stopAnimation: function () {\n            this.data.animate = false;\n            stopAnimation(this.data);\n        },\n        // Starts animation playback\n        startAnimation: function () {\n            this.data.animate = true;\n            applyAnimation(this.data);\n        },\n        // Sets a value indicating whether the animation should be looped or not.\n        // This might start the animation (if the 'animate' data attribute is set to true)\n        loop: function (value) {\n            this.data.loop = value;\n            applyAnimation(this.data);\n            return this;\n        },\n        // Gets the current frame number\n        currentFrame: function () {\n            return this.data.frame;\n        },\n        // Updates SpriteSpin to the specified frame.\n        updateFrame: function (frame) {\n            updateFrame(this.data, frame);\n            return this;\n        },\n        // Skips the given number of frames\n        skipFrames: function (step) {\n            var data = this.data;\n            updateFrame(data, data.frame + (data.reverse ? -step : +step));\n            return this;\n        },\n        // Updates SpriteSpin so that the next frame is shown\n        nextFrame: function () {\n            return this.skipFrames(1);\n        },\n        // Updates SpriteSpin so that the previous frame is shown\n        prevFrame: function () {\n            return this.skipFrames(-1);\n        },\n        // Starts the animations that will play until the given frame number is reached\n        // options:\n        //   force [boolean] starts the animation, even if current frame is the target frame\n        //   nearest [boolean] animates to the direction with minimum distance to the target frame\n        playTo: function (frame, options) {\n            var data = this.data;\n            options = options || {};\n            if (!options.force && data.frame === frame) {\n                return;\n            }\n            if (options.nearest) {\n                // distance to the target frame\n                var a = frame - data.frame;\n                // distance to last frame and the to target frame\n                var b = frame > data.frame ? a - data.frames : a + data.frames;\n                // minimum distance\n                var c = Math.abs(a) < Math.abs(b) ? a : b;\n                data.reverse = c < 0;\n            }\n            data.animate = true;\n            data.loop = false;\n            data.stopFrame = frame;\n            applyAnimation(data);\n            return this;\n        }\n    });\n\n    function pick(target, names) {\n        for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {\n            var name_1 = names_1[_i];\n            if (target[name_1] || name_1 in target) {\n                return name_1;\n            }\n        }\n        return names[0];\n    }\n    var browser = {\n        requestFullscreen: pick(document.documentElement, [\n            'requestFullscreen',\n            'webkitRequestFullScreen',\n            'mozRequestFullScreen',\n            'msRequestFullscreen'\n        ]),\n        exitFullscreen: pick(document, [\n            'exitFullscreen',\n            'webkitExitFullscreen',\n            'webkitCancelFullScreen',\n            'mozCancelFullScreen',\n            'msExitFullscreen'\n        ]),\n        fullscreenElement: pick(document, [\n            'fullscreenElement',\n            'webkitFullscreenElement',\n            'webkitCurrentFullScreenElement',\n            'mozFullScreenElement',\n            'msFullscreenElement'\n        ]),\n        fullscreenEnabled: pick(document, [\n            'fullscreenEnabled',\n            'webkitFullscreenEnabled',\n            'mozFullScreenEnabled',\n            'msFullscreenEnabled'\n        ]),\n        fullscreenchange: pick(document, [\n            'onfullscreenchange',\n            'onwebkitfullscreenchange',\n            'onmozfullscreenchange',\n            'onMSFullscreenChange'\n        ]).replace(/^on/, ''),\n        fullscreenerror: pick(document, [\n            'onfullscreenerror',\n            'onwebkitfullscreenerror',\n            'onmozfullscreenerror',\n            'onMSFullscreenError'\n        ]).replace(/^on/, '')\n    };\n    var changeEvent = browser.fullscreenchange + '.' + namespace + '-fullscreen';\n    function unbindChangeEvent() {\n        $$1(document).unbind(changeEvent);\n    }\n    function bindChangeEvent(callback) {\n        unbindChangeEvent();\n        $$1(document).bind(changeEvent, callback);\n    }\n    var orientationEvent = 'orientationchange.' + namespace + '-fullscreen';\n    function unbindOrientationEvent() {\n        $$1(window).unbind(orientationEvent);\n    }\n    function bindOrientationEvent(callback) {\n        unbindOrientationEvent();\n        $$1(window).bind(orientationEvent, callback);\n    }\n    function requestFullscreenNative(e) {\n        e = e || document.documentElement;\n        e[browser.requestFullscreen]();\n    }\n    function exitFullscreen() {\n        return document[browser.exitFullscreen]();\n    }\n    function fullscreenEnabled() {\n        return document[browser.fullscreenEnabled];\n    }\n    function fullscreenElement() {\n        return document[browser.fullscreenElement];\n    }\n    function isFullscreen() {\n        return !!fullscreenElement();\n    }\n    function toggleFullscreen(data, opts) {\n        if (isFullscreen()) {\n            this.apiRequestFullscreen(opts);\n        }\n        else {\n            this.exitFullscreen();\n        }\n    }\n    function requestFullscreen(data, opts) {\n        opts = opts || {};\n        var oWidth = data.width;\n        var oHeight = data.height;\n        var oSource = data.source;\n        var oSize = data.sizeMode;\n        var oResponsive = data.responsive;\n        var enter = function () {\n            data.width = window.screen.width;\n            data.height = window.screen.height;\n            data.source = (opts.source || oSource);\n            data.sizeMode = opts.sizeMode || 'fit';\n            data.responsive = false;\n            boot(data);\n        };\n        var exit = function () {\n            data.width = oWidth;\n            data.height = oHeight;\n            data.source = oSource;\n            data.sizeMode = oSize;\n            data.responsive = oResponsive;\n            boot(data);\n        };\n        bindChangeEvent(function () {\n            if (isFullscreen()) {\n                enter();\n                bindOrientationEvent(enter);\n            }\n            else {\n                unbindChangeEvent();\n                unbindOrientationEvent();\n                exit();\n            }\n        });\n        requestFullscreenNative(data.target[0]);\n    }\n    extendApi({\n        fullscreenEnabled: fullscreenEnabled,\n        fullscreenElement: fullscreenElement,\n        exitFullscreen: exitFullscreen,\n        toggleFullscreen: function (opts) {\n            toggleFullscreen(this.data, opts);\n        },\n        requestFullscreen: function (opts) {\n            requestFullscreen(this.data, opts);\n        }\n    });\n\n    (function () {\n        var NAME = 'click';\n        function click(e, data) {\n            if (data.loading || !data.stage.is(':visible')) {\n                return;\n            }\n            updateInput(e, data);\n            var input = getInputState(data);\n            var half, pos;\n            var target = data.target, offset = target.offset();\n            if (data.orientation === 'horizontal') {\n                half = target.innerWidth() / 2;\n                pos = input.currentX - offset.left;\n            }\n            else {\n                half = target.innerHeight() / 2;\n                pos = input.currentY - offset.top;\n            }\n            updateFrame(data, data.frame + (pos > half ? 1 : -1));\n        }\n        registerPlugin(NAME, {\n            name: NAME,\n            mouseup: click,\n            touchend: click\n        });\n    })();\n\n    (function () {\n        var NAME = 'drag';\n        function getState$$1(data) {\n            return getPluginState(data, NAME);\n        }\n        function getAxis(data) {\n            if (typeof data.orientation === 'number') {\n                return data.orientation * Math.PI / 180;\n            }\n            if (data.orientation === 'horizontal') {\n                return 0;\n            }\n            return Math.PI / 2;\n        }\n        function onInit(e, data) {\n            var state = getState$$1(data);\n            var d = [200, 1500];\n            var t = data.touchScrollTimer || d;\n            state.minTime = t[0] || d[0];\n            state.maxTime = t[1] || d[1];\n        }\n        function dragStart(e, data) {\n            var state = getState$$1(data);\n            if (data.loading || is(data, 'dragging') || data['zoomPinFrame'] && !data.stage.is(':visible')) {\n                return;\n            }\n            // Touch scroll can only be disabled by cancelling the 'touchstart' event.\n            // If we would try to cancel the 'touchmove' event during a scroll\n            // chrome browser raises an error\n            //\n            // When a user interacts with sprite spin, we dont know whether the intention\n            // is to scroll the page or to roll the spin.\n            //\n            // On first interaction with SpriteSpin the scroll is not disabled\n            // On double tap within 200ms the scroll is not disabled\n            // Scroll is only disabled if there was an interaction with SpriteSpin in the past 1500ms\n            var now = new Date().getTime();\n            if (state.endAt && (now - state.endAt > state.maxTime)) {\n                // reset timer if the user has no interaction with spritespin within 1500ms\n                state.startAt = null;\n                state.endAt = null;\n            }\n            if (state.startAt && (now - state.startAt > state.minTime)) {\n                // disable scroll only if there was already an interaction with spritespin\n                // however, allow scrolling on double tab within 200ms\n                e.preventDefault();\n            }\n            state.startAt = now;\n            state.wasPlaying = !!getPlaybackState(data).handler;\n            state.frame = data.frame || 0;\n            state.lane = data.lane || 0;\n            flag(data, 'dragging', true);\n            updateInput(e, data);\n        }\n        function dragEnd(e, data) {\n            if (is(data, 'dragging')) {\n                getState$$1(data).endAt = new Date().getTime();\n                flag(data, 'dragging', false);\n                resetInput(data);\n                if (data.retainAnimate && getState$$1(data).wasPlaying) {\n                    startAnimation(data);\n                }\n            }\n        }\n        function drag(e, data) {\n            var state = getState$$1(data);\n            var input = getInputState(data);\n            if (!is(data, 'dragging')) {\n                return;\n            }\n            updateInput(e, data);\n            var rad = getAxis(data);\n            var sn = Math.sin(rad);\n            var cs = Math.cos(rad);\n            var x = ((input.nddX * cs - input.nddY * sn) * data.sense) || 0;\n            var y = ((input.nddX * sn + input.nddY * cs) * (data.senseLane || data.sense)) || 0;\n            // accumulate\n            state.frame += data.frames * x;\n            state.lane += data.lanes * y;\n            // update spritespin\n            var oldFrame = data.frame;\n            var oldLane = data.lane;\n            updateFrame(data, Math.floor(state.frame), Math.floor(state.lane));\n            stopAnimation(data);\n        }\n        function mousemove(e, data) {\n            dragStart(e, data);\n            drag(e, data);\n        }\n        registerPlugin('drag', {\n            name: 'drag',\n            onInit: onInit,\n            mousedown: dragStart,\n            mousemove: drag,\n            mouseup: dragEnd,\n            documentmousemove: drag,\n            documentmouseup: dragEnd,\n            touchstart: dragStart,\n            touchmove: drag,\n            touchend: dragEnd,\n            touchcancel: dragEnd\n        });\n        registerPlugin('move', {\n            name: 'move',\n            onInit: onInit,\n            mousemove: mousemove,\n            mouseleave: dragEnd,\n            touchstart: dragStart,\n            touchmove: drag,\n            touchend: dragEnd,\n            touchcancel: dragEnd\n        });\n    })();\n\n    (function () {\n        var NAME = 'hold';\n        function getState$$1(data) {\n            return getPluginState(data, NAME);\n        }\n        function rememberOptions(data) {\n            var state = getState$$1(data);\n            state.frameTime = data.frameTime;\n            state.animate = data.animate;\n            state.reverse = data.reverse;\n        }\n        function restoreOptions(data) {\n            var state = getState$$1(data);\n            data.frameTime = state.frameTime;\n            data.animate = state.animate;\n            data.reverse = state.reverse;\n        }\n        function start(e, data) {\n            if (is(data, 'loading') || is(data, 'dragging') || !data.stage.is(':visible')) {\n                return;\n            }\n            rememberOptions(data);\n            updateInput(e, data);\n            flag(data, 'dragging', true);\n            data.animate = true;\n            applyAnimation(data);\n        }\n        function stop(e, data) {\n            flag(data, 'dragging', false);\n            resetInput(data);\n            stopAnimation(data);\n            restoreOptions(data);\n            applyAnimation(data);\n        }\n        function update(e, data) {\n            if (!is(data, 'dragging')) {\n                return;\n            }\n            updateInput(e, data);\n            var input = getInputState(data);\n            var half, delta;\n            var target = data.target, offset = target.offset();\n            if (data.orientation === 'horizontal') {\n                half = target.innerWidth() / 2;\n                delta = (input.currentX - offset.left - half) / half;\n            }\n            else {\n                half = (data.height / 2);\n                delta = (input.currentY - offset.top - half) / half;\n            }\n            data.reverse = delta < 0;\n            delta = delta < 0 ? -delta : delta;\n            data.frameTime = 80 * (1 - delta) + 20;\n            if (((data.orientation === 'horizontal') && (input.dX < input.dY)) ||\n                ((data.orientation === 'vertical') && (input.dX < input.dY))) {\n                e.preventDefault();\n            }\n        }\n        function onFrame(e, data) {\n            data.animate = true;\n            applyAnimation(data);\n        }\n        registerPlugin(NAME, {\n            name: NAME,\n            mousedown: start,\n            mousemove: update,\n            mouseup: stop,\n            mouseleave: stop,\n            touchstart: start,\n            touchmove: update,\n            touchend: stop,\n            touchcancel: stop,\n            onFrame: onFrame\n        });\n    })();\n\n    (function () {\n        var NAME = 'swipe';\n        function getState$$1(data) {\n            return getPluginState(data, NAME);\n        }\n        function getOption(data, name, fallback) {\n            return data[name] || fallback;\n        }\n        function init(e, data) {\n            var state = getState$$1(data);\n            state.fling = getOption(data, 'swipeFling', 10);\n            state.snap = getOption(data, 'swipeSnap', 0.50);\n        }\n        function start(e, data) {\n            if (!data.loading && !is(data, 'dragging')) {\n                updateInput(e, data);\n                flag(data, 'dragging', true);\n            }\n        }\n        function update(e, data) {\n            if (!is(data, 'dragging')) {\n                return;\n            }\n            updateInput(e, data);\n            var frame = data.frame;\n            var lane = data.lane;\n            updateFrame(data, frame, lane);\n        }\n        function end(e, data) {\n            if (!is(data, 'dragging')) {\n                return;\n            }\n            flag(data, 'dragging', false);\n            var state = getState$$1(data);\n            var input = getInputState(data);\n            var frame = data.frame;\n            var lane = data.lane;\n            var snap = state.snap;\n            var fling = state.fling;\n            var dS, dF;\n            if (data.orientation === 'horizontal') {\n                dS = input.ndX;\n                dF = input.ddX;\n            }\n            else {\n                dS = input.ndY;\n                dF = input.ddY;\n            }\n            if (dS >= snap || dF >= fling) {\n                frame = data.frame - 1;\n            }\n            else if (dS <= -snap || dF <= -fling) {\n                frame = data.frame + 1;\n            }\n            resetInput(data);\n            updateFrame(data, frame, lane);\n            stopAnimation(data);\n        }\n        registerPlugin(NAME, {\n            name: NAME,\n            onLoad: init,\n            mousedown: start,\n            mousemove: update,\n            mouseup: end,\n            mouseleave: end,\n            touchstart: start,\n            touchmove: update,\n            touchend: end,\n            touchcancel: end\n        });\n    })();\n\n    (function () {\n        var NAME = 'wheel';\n        function wheel(e, data) {\n            if (!data.loading && data.stage.is(':visible')) {\n                e.preventDefault();\n                var we = e.originalEvent;\n                var signX = we.deltaX === 0 ? 0 : we.deltaX > 0 ? 1 : -1;\n                var signY = we.deltaY === 0 ? 0 : we.deltaY > 0 ? 1 : -1;\n                updateFrame(data, data.frame + signY, data.lane + signX);\n            }\n        }\n        registerPlugin(NAME, {\n            name: NAME,\n            wheel: wheel\n        });\n    })();\n\n    (function () {\n        var template = \"\\n<div class='spritespin-progress'>\\n  <div class='spritespin-progress-label'></div>\\n  <div class='spritespin-progress-bar'></div>\\n</div>\\n\";\n        function getState$$1(data) {\n            return getPluginState(data, NAME);\n        }\n        var NAME = 'progress';\n        function onInit(e, data) {\n            var state = getState$$1(data);\n            if (!state.stage) {\n                state.stage = $$1(template);\n                state.stage.appendTo(data.target);\n            }\n            state.stage.find('.spritespin-progress-label')\n                .text(\"0%\")\n                .css({ 'text-align': 'center' });\n            state.stage.find('.spritespin-progress-bar').css({\n                width: \"0%\"\n            });\n            state.stage.hide().fadeIn();\n        }\n        function onProgress(e, data) {\n            var state = getState$$1(data);\n            state.stage.find('.spritespin-progress-label')\n                .text(data.progress.percent + \"%\")\n                .css({ 'text-align': 'center' });\n            state.stage.find('.spritespin-progress-bar').css({\n                width: data.progress.percent + \"%\"\n            });\n        }\n        function onLoad(e, data) {\n            $$1(getState$$1(data).stage).fadeOut();\n        }\n        function onDestroy(e, data) {\n            $$1(getState$$1(data).stage).remove();\n        }\n        registerPlugin(NAME, {\n            name: NAME,\n            onInit: onInit,\n            onProgress: onProgress,\n            onLoad: onLoad,\n            onDestroy: onDestroy\n        });\n    })();\n\n    (function () {\n        var NAME = '360';\n        function onLoad(e, data) {\n            data.stage.find('.spritespin-frames').detach();\n            if (data.renderer === 'image') {\n                $(data.images).addClass('spritespin-frames').appendTo(data.stage);\n            }\n        }\n        function onDraw(e, data) {\n            var specs = findSpecs(data.metrics, data.frames, data.frame, data.lane);\n            var sheet = specs.sheet;\n            var sprite = specs.sprite;\n            if (!sheet || !sprite) {\n                return;\n            }\n            var src = data.source[sheet.id];\n            var image = data.images[sheet.id];\n            if (data.renderer === 'canvas') {\n                data.canvas.show();\n                var w = data.canvas[0].width / data.canvasRatio;\n                var h = data.canvas[0].height / data.canvasRatio;\n                data.context.clearRect(0, 0, w, h);\n                data.context.drawImage(image, sprite.sampledX, sprite.sampledY, sprite.sampledWidth, sprite.sampledHeight, 0, 0, w, h);\n                return;\n            }\n            var scaleX = data.stage.innerWidth() / sprite.sampledWidth;\n            var scaleY = data.stage.innerHeight() / sprite.sampledHeight;\n            var top = Math.floor(-sprite.sampledY * scaleY);\n            var left = Math.floor(-sprite.sampledX * scaleX);\n            var width = Math.floor(sheet.sampledWidth * scaleX);\n            var height = Math.floor(sheet.sampledHeight * scaleY);\n            if (data.renderer === 'background') {\n                data.stage.css({\n                    'background-image': \"url('\" + src + \"')\",\n                    'background-position': left + \"px \" + top + \"px\",\n                    'background-repeat': 'no-repeat',\n                    // set custom background size to enable responsive rendering\n                    '-webkit-background-size': width + \"px \" + height + \"px\",\n                    '-moz-background-size': width + \"px \" + height + \"px\",\n                    '-o-background-size': width + \"px \" + height + \"px\",\n                    'background-size': width + \"px \" + height + \"px\" /* Chrome, Firefox 4+, IE 9+, Opera, Safari 5+ */\n                });\n                return;\n            }\n            $(data.images).hide();\n            $(image).show().css({\n                position: 'absolute',\n                top: top,\n                left: left,\n                'max-width': 'initial',\n                width: width,\n                height: height\n            });\n        }\n        registerPlugin(NAME, {\n            name: NAME,\n            onLoad: onLoad,\n            onDraw: onDraw\n        });\n    })();\n\n    (function () {\n        var NAME = 'blur';\n        function getState$$1(data) {\n            return getPluginState(data, NAME);\n        }\n        function getOption(data, name, fallback) {\n            return data[name] || fallback;\n        }\n        function init(e, data) {\n            var state = getState$$1(data);\n            state.canvas = state.canvas || $$1(\"<canvas class='blur-layer'></canvas>\");\n            state.context = state.context || state.canvas[0].getContext('2d');\n            state.steps = state.steps || [];\n            state.fadeTime = Math.max(getOption(data, 'blurFadeTime', 200), 1);\n            state.frameTime = Math.max(getOption(data, 'blurFrameTime', data.frameTime), 16);\n            state.trackTime = null;\n            state.cssBlur = !!getOption(data, 'blurCss', false);\n            var inner = getInnerSize(data);\n            var outer = data.responsive ? getComputedSize(data) : getOuterSize(data);\n            var css = getInnerLayout(data.sizeMode, inner, outer);\n            state.canvas[0].width = data.width * data.canvasRatio;\n            state.canvas[0].height = data.height * data.canvasRatio;\n            state.canvas.css(css).show();\n            state.context.scale(data.canvasRatio, data.canvasRatio);\n            data.target.append(state.canvas);\n        }\n        function onFrame(e, data) {\n            var state = getState$$1(data);\n            trackFrame(data);\n            if (state.timeout == null) {\n                loop(data);\n            }\n        }\n        function trackFrame(data) {\n            var state = getState$$1(data);\n            var ani = getPlaybackState(data);\n            // distance between frames\n            var d = Math.abs(data.frame - ani.lastFrame);\n            // shortest distance\n            d = d >= data.frames / 2 ? data.frames - d : d;\n            state.steps.unshift({\n                frame: data.frame,\n                lane: data.lane,\n                live: 1,\n                step: state.frameTime / state.fadeTime,\n                d: d,\n                alpha: 0\n            });\n        }\n        var toRemove = [];\n        function removeOldFrames(frames) {\n            toRemove.length = 0;\n            for (var i = 0; i < frames.length; i += 1) {\n                if (frames[i].alpha <= 0) {\n                    toRemove.push(i);\n                }\n            }\n            for (var _i = 0, toRemove_1 = toRemove; _i < toRemove_1.length; _i++) {\n                var item = toRemove_1[_i];\n                frames.splice(item, 1);\n            }\n        }\n        function loop(data) {\n            var state = getState$$1(data);\n            state.timeout = window.setTimeout(function () { tick(data); }, state.frameTime);\n        }\n        function killLoop(data) {\n            var state = getState$$1(data);\n            window.clearTimeout(state.timeout);\n            state.timeout = null;\n        }\n        function applyCssBlur(canvas, d) {\n            var amount = Math.min(Math.max((d / 2) - 4, 0), 2.5);\n            var blur = \"blur(\" + amount + \"px)\";\n            canvas.css({\n                '-webkit-filter': blur,\n                filter: blur\n            });\n        }\n        function clearFrame(data, state) {\n            state.canvas.show();\n            var w = state.canvas[0].width / data.canvasRatio;\n            var h = state.canvas[0].height / data.canvasRatio;\n            // state.context.clearRect(0, 0, w, h)\n        }\n        function drawFrame(data, state, step) {\n            if (step.alpha <= 0) {\n                return;\n            }\n            var specs = findSpecs(data.metrics, data.frames, step.frame, step.lane);\n            var sheet = specs.sheet;\n            var sprite = specs.sprite;\n            if (!sheet || !sprite) {\n                return;\n            }\n            var src = data.source[sheet.id];\n            var image = data.images[sheet.id];\n            if (image.complete === false) {\n                return;\n            }\n            state.canvas.show();\n            var w = state.canvas[0].width / data.canvasRatio;\n            var h = state.canvas[0].height / data.canvasRatio;\n            state.context.globalAlpha = step.alpha;\n            state.context.drawImage(image, sprite.sampledX, sprite.sampledY, sprite.sampledWidth, sprite.sampledHeight, 0, 0, w, h);\n        }\n        function tick(data) {\n            var state = getState$$1(data);\n            killLoop(data);\n            if (!state.context) {\n                return;\n            }\n            var d = 0;\n            clearFrame(data, state);\n            state.context.clearRect(0, 0, data.width, data.height);\n            for (var _i = 0, _a = state.steps; _i < _a.length; _i++) {\n                var step = _a[_i];\n                step.live = Math.max(step.live - step.step, 0);\n                step.alpha = Math.max(step.live - 0.25, 0);\n                drawFrame(data, state, step);\n                d += step.alpha + step.d;\n            }\n            if (state.cssBlur) {\n                applyCssBlur(state.canvas, d);\n            }\n            removeOldFrames(state.steps);\n            if (state.steps.length) {\n                loop(data);\n            }\n        }\n        registerPlugin(NAME, {\n            name: NAME,\n            onLoad: init,\n            onFrameChanged: onFrame\n        });\n    })();\n\n    (function () {\n        var max = Math.max;\n        var min = Math.min;\n        var NAME = 'ease';\n        function getState$$1(data) {\n            return getPluginState(data, NAME);\n        }\n        function getOption(data, name, fallback) {\n            return data[name] || fallback;\n        }\n        function init(e, data) {\n            var state = getState$$1(data);\n            state.maxSamples = max(getOption(data, 'easeMaxSamples', 5), 0);\n            state.damping = max(min(getOption(data, 'easeDamping', 0.9), 0.999), 0);\n            state.abortTime = max(getOption(data, 'easeAbortTime', 250), 16);\n            state.updateTime = max(getOption(data, 'easeUpdateTime', data.frameTime), 16);\n            state.samples = [];\n            state.steps = [];\n        }\n        function update(e, data) {\n            if (is(data, 'dragging')) {\n                killLoop(data);\n                sampleInput(data);\n            }\n        }\n        function end(e, data) {\n            var state = getState$$1(data);\n            var samples = state.samples;\n            var last;\n            var lanes = 0;\n            var frames = 0;\n            var time = 0;\n            for (var _i = 0, samples_1 = samples; _i < samples_1.length; _i++) {\n                var sample = samples_1[_i];\n                if (!last) {\n                    last = sample;\n                    continue;\n                }\n                var dt = sample.time - last.time;\n                if (dt > state.abortTime) {\n                    lanes = frames = time = 0;\n                    return killLoop(data);\n                }\n                frames += sample.frame - last.frame;\n                lanes += sample.lane - last.lane;\n                time += dt;\n                last = sample;\n            }\n            samples.length = 0;\n            if (!time) {\n                return;\n            }\n            state.lane = data.lane;\n            state.lanes = 0;\n            state.laneStep = lanes / time * state.updateTime;\n            state.frame = data.frame;\n            state.frames = 0;\n            state.frameStep = frames / time * state.updateTime;\n            loop(data);\n        }\n        function sampleInput(data) {\n            var state = getState$$1(data);\n            // add a new sample\n            state.samples.push({\n                time: new Date().getTime(),\n                frame: data.frame,\n                lane: data.lane\n            });\n            // drop old samples\n            while (state.samples.length > state.maxSamples) {\n                state.samples.shift();\n            }\n        }\n        function killLoop(data) {\n            var state = getState$$1(data);\n            if (state.handler != null) {\n                window.clearTimeout(state.handler);\n                state.handler = null;\n            }\n        }\n        function loop(data) {\n            var state = getState$$1(data);\n            state.handler = window.setTimeout(function () { tick(data); }, state.updateTime);\n        }\n        function tick(data) {\n            var state = getState$$1(data);\n            state.lanes += state.laneStep;\n            state.frames += state.frameStep;\n            state.laneStep *= state.damping;\n            state.frameStep *= state.damping;\n            var frame = Math.floor(state.frame + state.frames);\n            var lane = Math.floor(state.lane + state.lanes);\n            updateFrame(data, frame, lane);\n            if (is(data, 'dragging')) {\n                killLoop(data);\n            }\n            else if (Math.abs(state.frameStep) > 0.005 || Math.abs(state.laneStep) > 0.005) {\n                loop(data);\n            }\n            else {\n                killLoop(data);\n            }\n        }\n        registerPlugin(NAME, {\n            name: NAME,\n            onLoad: init,\n            mousemove: update,\n            mouseup: end,\n            mouseleave: end,\n            touchmove: update,\n            touchend: end,\n            touchcancel: end\n        });\n    })();\n\n    (function () {\n        var NAME = 'gallery';\n        function getState$$1(data) {\n            return getPluginState(data, NAME);\n        }\n        function getOption(data, name, fallback) {\n            return data[name] || fallback;\n        }\n        function load(e, data) {\n            var state = getState$$1(data);\n            state.images = [];\n            state.offsets = [];\n            state.frame = data.frame;\n            state.speed = getOption(data, 'gallerySpeed', 500);\n            state.opacity = getOption(data, 'galleryOpacity', 0.25);\n            state.stage = getOption(data, 'galleryStage', $$1('<div></div>'));\n            state.stage.empty().addClass('gallery-stage').prependTo(data.stage);\n            var size = 0;\n            for (var _i = 0, _a = data.images; _i < _a.length; _i++) {\n                var image = _a[_i];\n                var naturalSize$$1 = naturalSize(image);\n                var scale = data.height / naturalSize$$1.height;\n                var img = $$1(image);\n                state.stage.append(img);\n                state.images.push(img);\n                state.offsets.push(-size + (data.width - image.width * scale) / 2);\n                size += data.width;\n                img.css({\n                    'max-width': 'initial',\n                    opacity: state.opacity,\n                    width: data.width,\n                    height: data.height\n                });\n            }\n            var innerSize = getInnerSize(data);\n            var outerSize = data.responsive ? getComputedSize(data) : getOuterSize(data);\n            var layout = getInnerLayout(data.sizeMode, innerSize, outerSize);\n            state.stage.css(layout).css({ width: size, left: state.offsets[state.frame] });\n            state.images[state.frame].animate({ opacity: 1 }, { duration: state.speed });\n        }\n        function draw(e, data) {\n            var state = getState$$1(data);\n            var input = getInputState(data);\n            var isDragging = is(data, 'dragging');\n            if (state.frame !== data.frame && !isDragging) {\n                state.stage.stop(true, false).animate({ left: state.offsets[data.frame] }, { duration: state.speed });\n                state.images[state.frame].animate({ opacity: state.opacity }, { duration: state.speed });\n                state.frame = data.frame;\n                state.images[state.frame].animate({ opacity: 1 }, { duration: state.speed });\n                state.stage.animate({ left: state.offsets[state.frame] });\n            }\n            else if (isDragging || state.dX !== input.dX) {\n                state.dX = input.dX;\n                state.ddX = input.ddX;\n                state.stage.stop(true, true).css({ left: state.offsets[state.frame] + state.dX });\n            }\n        }\n        registerPlugin(NAME, {\n            name: NAME,\n            onLoad: load,\n            onDraw: draw\n        });\n    })();\n\n    (function () {\n        var NAME = 'panorama';\n        function getState$$1(data) {\n            return getPluginState(data, NAME);\n        }\n        function onLoad(e, data) {\n            var state = getState$$1(data);\n            var sprite = data.metrics[0];\n            if (!sprite) {\n                return;\n            }\n            if (data.orientation === 'horizontal') {\n                state.scale = data.target.innerHeight() / sprite.sampledHeight;\n                data.frames = sprite.sampledWidth;\n            }\n            else {\n                state.scale = data.target.innerWidth() / sprite.sampledWidth;\n                data.frames = sprite.sampledHeight;\n            }\n            var width = Math.floor(sprite.sampledWidth * state.scale);\n            var height = Math.floor(sprite.sampledHeight * state.scale);\n            data.stage.css({\n                'background-image': \"url(\" + data.source[sprite.id] + \")\",\n                'background-repeat': 'repeat-both',\n                // set custom background size to enable responsive rendering\n                '-webkit-background-size': width + \"px \" + height + \"px\",\n                '-moz-background-size': width + \"px \" + height + \"px\",\n                '-o-background-size': width + \"px \" + height + \"px\",\n                'background-size': width + \"px \" + height + \"px\" /* Chrome, Firefox 4+, IE 9+, Opera, Safari 5+ */\n            });\n        }\n        function onDraw(e, data) {\n            var state = getState$$1(data);\n            var px = data.orientation === 'horizontal' ? 1 : 0;\n            var py = px ? 0 : 1;\n            var offset = data.frame % data.frames;\n            var left = Math.round(px * offset * state.scale);\n            var top = Math.round(py * offset * state.scale);\n            data.stage.css({ 'background-position': left + \"px \" + top + \"px\" });\n        }\n        registerPlugin(NAME, {\n            name: NAME,\n            onLoad: onLoad,\n            onDraw: onDraw\n        });\n    })();\n\n    (function () {\n        var NAME = 'zoom';\n        function getState$$1(data) {\n            return getPluginState(data, NAME);\n        }\n        function getOption(data, name, fallback) {\n            return name in data ? data[name] : fallback;\n        }\n        function onInit(e, data) {\n            var state = getState$$1(data);\n            state.source = getOption(data, 'zoomSource', data.source);\n            state.useWheel = getOption(data, 'zoomUseWheel', false);\n            state.useClick = getOption(data, 'zoomUseClick', true);\n            state.pinFrame = getOption(data, 'zoomPinFrame', true);\n            state.doubleClickTime = getOption(data, 'zoomDoubleClickTime', 500);\n            state.stage = state.stage || $$1(\"<div class='zoom-stage'></div>\");\n            state.stage.css({\n                width: '100%',\n                height: '100%',\n                top: 0,\n                left: 0,\n                bottom: 0,\n                right: 0,\n                position: 'absolute'\n            })\n                .appendTo(data.target)\n                .hide();\n        }\n        function onDestroy(e, data) {\n            var state = getState$$1(data);\n            if (state.stage) {\n                state.stage.remove();\n                delete state.stage;\n            }\n        }\n        function updateInput$$1(e, data) {\n            var state = getState$$1(data);\n            if (!state.stage.is(':visible')) {\n                return;\n            }\n            e.preventDefault();\n            if (state.pinFrame) {\n                // hack into drag/move module and disable dragging\n                // prevents frame change during zoom mode\n                flag(data, 'dragging', false);\n            }\n            // grab touch/cursor position\n            var cursor = getCursorPosition(e);\n            // normalize cursor position into [0:1] range\n            var x = cursor.x / data.width;\n            var y = cursor.y / data.height;\n            if (state.oldX == null) {\n                state.oldX = x;\n                state.oldY = y;\n            }\n            if (state.currentX == null) {\n                state.currentX = x;\n                state.currentY = y;\n            }\n            // calculate move delta since last frame and remember current position\n            var dx = x - state.oldX;\n            var dy = y - state.oldY;\n            state.oldX = x;\n            state.oldY = y;\n            // invert drag direction for touch events to enable 'natural' scrolling\n            if (e.type.match(/touch/)) {\n                dx = -dx;\n                dy = -dy;\n            }\n            // accumulate display coordinates\n            state.currentX = clamp(state.currentX + dx, 0, 1);\n            state.currentY = clamp(state.currentY + dy, 0, 1);\n            updateFrame(data, data.frame, data.lane);\n        }\n        function onClick(e, data) {\n            var state = getState$$1(data);\n            if (!state.useClick) {\n                return;\n            }\n            e.preventDefault();\n            // simulate double click\n            var clickTime = new Date().getTime();\n            if (!state.clickTime) {\n                // on first click\n                state.clickTime = clickTime;\n                return;\n            }\n            // on second click\n            var timeDelta = clickTime - state.clickTime;\n            if (timeDelta > state.doubleClickTime) {\n                // took too long, back to first click\n                state.clickTime = clickTime;\n                return;\n            }\n            // on valid double click\n            state.clickTime = undefined;\n            if (toggleZoom(data)) {\n                updateInput$$1(e, data);\n            }\n        }\n        function onMove(e, data) {\n            var state = getState$$1(data);\n            if (state.stage.is(':visible')) {\n                updateInput$$1(e, data);\n            }\n        }\n        function onDraw(e, data) {\n            var state = getState$$1(data);\n            // calculate the frame index\n            var index = data.lane * data.frames + data.frame;\n            // get the zoom image. Use original frames as fallback. This won't work for spritesheets\n            var source = state.source[index];\n            var spec = findSpecs(data.metrics, data.frames, data.frame, data.lane);\n            // get display position\n            var x = state.currentX;\n            var y = state.currentY;\n            // fallback to centered position\n            if (x == null) {\n                x = state.currentX = 0.5;\n                y = state.currentY = 0.5;\n            }\n            if (source) {\n                // scale up from [0:1] to [0:100] range\n                x = Math.floor(x * 100);\n                y = Math.floor(y * 100);\n                // update background image and position\n                state.stage.css({\n                    'background-repeat': 'no-repeat',\n                    'background-image': \"url('\" + source + \"')\",\n                    'background-position': x + \"% \" + y + \"%\"\n                });\n            }\n            else if (spec.sheet && spec.sprite) {\n                var sprite = spec.sprite;\n                var sheet = spec.sheet;\n                var src = data.source[sheet.id];\n                var left = -Math.floor(sprite.sampledX + x * (sprite.sampledWidth - data.width));\n                var top_1 = -Math.floor(sprite.sampledY + y * (sprite.sampledHeight - data.height));\n                var width = sheet.sampledWidth;\n                var height = sheet.sampledHeight;\n                state.stage.css({\n                    'background-image': \"url('\" + src + \"')\",\n                    'background-position': left + \"px \" + top_1 + \"px\",\n                    'background-repeat': 'no-repeat',\n                    // set custom background size to enable responsive rendering\n                    '-webkit-background-size': width + \"px \" + height + \"px\",\n                    '-moz-background-size': width + \"px \" + height + \"px\",\n                    '-o-background-size': width + \"px \" + height + \"px\",\n                    'background-size': width + \"px \" + height + \"px\" /* Chrome, Firefox 4+, IE 9+, Opera, Safari 5+ */\n                });\n            }\n        }\n        function toggleZoom(data) {\n            var state = getState$$1(data);\n            if (!state.stage) {\n                throw new Error('zoom module is not initialized or is not available.');\n            }\n            if (state.stage.is(':visible')) {\n                showZoom(data);\n            }\n            else {\n                hideZoom(data);\n                return true;\n            }\n            return false;\n        }\n        function showZoom(data) {\n            var state = getState$$1(data);\n            state.stage.fadeOut();\n            data.stage.fadeIn();\n        }\n        function hideZoom(data) {\n            var state = getState$$1(data);\n            state.stage.fadeIn();\n            data.stage.fadeOut();\n        }\n        function wheel(e, data) {\n            var state = getState$$1(data);\n            if (!data.loading && state.useWheel) {\n                var we = e.originalEvent;\n                var signY = we.deltaY === 0 ? 0 : we.deltaY > 0 ? 1 : -1;\n                if (typeof state.useWheel === 'number') {\n                    signY *= state.useWheel;\n                }\n                if (state.stage.is(':visible') && signY > 0) {\n                    e.preventDefault();\n                    showZoom(data);\n                }\n                if (!state.stage.is(':visible') && signY < 0) {\n                    e.preventDefault();\n                    hideZoom(data);\n                }\n            }\n        }\n        registerPlugin(NAME, {\n            name: NAME,\n            mousedown: onClick,\n            touchstart: onClick,\n            mousemove: onMove,\n            touchmove: onMove,\n            wheel: wheel,\n            onInit: onInit,\n            onDestroy: onDestroy,\n            onDraw: onDraw\n        });\n        extendApi({\n            toggleZoom: function () { toggleZoom(this.data); } // tslint:disable-line\n        });\n    })();\n\n    var Utils = _Utils;\n\n    exports.Utils = Utils;\n    exports.sourceArray = sourceArray;\n    exports.Api = Api;\n    exports.extendApi = extendApi;\n    exports.instances = instances;\n    exports.applyEvents = applyEvents;\n    exports.boot = boot;\n    exports.create = create;\n    exports.createOrUpdate = createOrUpdate;\n    exports.destroy = destroy;\n    exports.namespace = namespace;\n    exports.eventNames = eventNames;\n    exports.callbackNames = callbackNames;\n    exports.eventsToPrevent = eventsToPrevent;\n    exports.defaults = defaults;\n    exports.getInputState = getInputState;\n    exports.updateInput = updateInput;\n    exports.resetInput = resetInput;\n    exports.applyLayout = applyLayout;\n    exports.getPlaybackState = getPlaybackState;\n    exports.updateFrame = updateFrame;\n    exports.stopAnimation = stopAnimation;\n    exports.applyAnimation = applyAnimation;\n    exports.startAnimation = startAnimation;\n    exports.registerPlugin = registerPlugin;\n    exports.registerModule = registerModule;\n    exports.getPlugin = getPlugin;\n    exports.applyPlugins = applyPlugins;\n    exports.getState = getState;\n    exports.getPluginState = getPluginState;\n    exports.is = is;\n    exports.flag = flag;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));","Sm_ListingTabs/js/owl.carousel.js":"/**\n * Owl carousel\n * @version 2.0.0\n * @author Bartosz Wojciechowski\n * @license The MIT License (MIT)\n * @todo Lazy Load Icon\n * @todo prevent animationend bubling\n * @todo itemsScaleUp\n * @todo Test Zepto\n * @todo stagePadding calculate wrong active classes\n */\ndefine( [ \"jquery\" ], function ( $ ) {  \n;\n(function ($, window, document, undefined) {\n\n    var drag, state, e;\n\n    /**\n     * Template for status information about drag and touch events.\n     * @private\n     */\n    drag = {\n        start: 0,\n        startX: 0,\n        startY: 0,\n        current: 0,\n        currentX: 0,\n        currentY: 0,\n        offsetX: 0,\n        offsetY: 0,\n        distance: null,\n        startTime: 0,\n        endTime: 0,\n        updatedX: 0,\n        targetEl: null\n    };\n\n    /**\n     * Template for some status informations.\n     * @private\n     */\n    state = {\n        isTouch: false,\n        isScrolling: false,\n        isSwiping: false,\n        direction: false,\n        inMotion: false\n    };\n\n    /**\n     * Event functions references.\n     * @private\n     */\n    e = {\n        _onDragStart: null,\n        _onDragMove: null,\n        _onDragEnd: null,\n        _transitionEnd: null,\n        _resizer: null,\n        _responsiveCall: null,\n        _goToLoop: null,\n        _checkVisibile: null\n    };\n\n    /**\n     * Creates a carousel.\n     * @class The Owl Carousel.\n     * @public\n     * @param {HTMLElement|jQuery} element - The element to create the carousel for.\n     * @param {Object} [options] - The options\n     */\n    function Owl(element, options) {\n\n        /**\n         * Current settings for the carousel.\n         * @public\n         */\n        this.settings = null;\n\n        /**\n         * Current options set by the caller including defaults.\n         * @public\n         */\n        this.options = $.extend({}, Owl.Defaults, options);\n\n        /**\n         * Plugin element.\n         * @public\n         */\n        this.$element = $(element);\n\n        /**\n         * Caches informations about drag and touch events.\n         */\n        this.drag = $.extend({}, drag);\n\n        /**\n         * Caches some status informations.\n         * @protected\n         */\n        this.state = $.extend({}, state);\n\n        /**\n         * @protected\n         * @todo Must be documented\n         */\n        this.e = $.extend({}, e);\n\n        /**\n         * References to the running plugins of this carousel.\n         * @protected\n         */\n        this._plugins = {};\n\n        /**\n         * Currently suppressed events to prevent them from beeing retriggered.\n         * @protected\n         */\n        this._supress = {};\n\n        /**\n         * Absolute current position.\n         * @protected\n         */\n        this._current = null;\n\n        /**\n         * Animation speed in milliseconds.\n         * @protected\n         */\n        this._speed = null;\n\n        /**\n         * Coordinates of all items in pixel.\n         * @todo The name of this member is missleading.\n         * @protected\n         */\n        this._coordinates = [];\n\n        /**\n         * Current breakpoint.\n         * @todo Real media queries would be nice.\n         * @protected\n         */\n        this._breakpoint = null;\n\n        /**\n         * Current width of the plugin element.\n         */\n        this._width = null;\n\n        /**\n         * All real items.\n         * @protected\n         */\n        this._items = [];\n\n        /**\n         * All cloned items.\n         * @protected\n         */\n        this._clones = [];\n\n        /**\n         * Merge values of all items.\n         * @todo Maybe this could be part of a plugin.\n         * @protected\n         */\n        this._mergers = [];\n\n        /**\n         * Invalidated parts within the update process.\n         * @protected\n         */\n        this._invalidated = {};\n\n        /**\n         * Ordered list of workers for the update process.\n         * @protected\n         */\n        this._pipe = [];\n\n        $.each(Owl.Plugins, $.proxy(function (key, plugin) {\n            this._plugins[key[0].toLowerCase() + key.slice(1)]\n                = new plugin(this);\n        }, this));\n\n        $.each(Owl.Pipe, $.proxy(function (priority, worker) {\n            this._pipe.push({\n                'filter': worker.filter,\n                'run': $.proxy(worker.run, this)\n            });\n        }, this));\n\n        this.setup();\n        this.initialize();\n    }\n\n    /**\n     * Default options for the carousel.\n     * @public\n     */\n    Owl.Defaults = {\n        items: 3,\n        loop: false,\n        center: false,\n\n        mouseDrag: true,\n        touchDrag: true,\n        pullDrag: true,\n        freeDrag: false,\n\n        margin: 0,\n        stagePadding: 0,\n\n        merge: false,\n        mergeFit: true,\n        autoWidth: false,\n\n        startPosition: 0,\n        rtl: false,\n\n        smartSpeed: 250,\n        fluidSpeed: false,\n        dragEndSpeed: false,\n\n        responsive: {},\n        responsiveRefreshRate: 200,\n        responsiveBaseElement: window,\n        responsiveClass: false,\n\n        fallbackEasing: 'swing',\n\n        info: false,\n\n        nestedItemSelector: false,\n        itemElement: 'div',\n        stageElement: 'div',\n\n        // Classes and Names\n        themeClass: 'owl-theme',\n        baseClass: 'owl-carousel',\n        itemClass: 'owl-item',\n        centerClass: 'center',\n        activeClass: 'active'\n    };\n\n    /**\n     * Enumeration for width.\n     * @public\n     * @readonly\n     * @enum {String}\n     */\n    Owl.Width = {\n        Default: 'default',\n        Inner: 'inner',\n        Outer: 'outer'\n    };\n\n    /**\n     * Contains all registered plugins.\n     * @public\n     */\n    Owl.Plugins = {};\n\n    /**\n     * Update pipe.\n     */\n    Owl.Pipe = [\n        {\n            filter: ['width', 'items', 'settings'],\n            run: function (cache) {\n                cache.current = this._items && this._items[this.relative(this._current)];\n            }\n        },\n        {\n            filter: ['items', 'settings'],\n            run: function () {\n                var cached = this._clones,\n                    clones = this.$stage.children('.cloned');\n\n                if (clones.length !== cached.length || (!this.settings.loop && cached.length > 0)) {\n                    this.$stage.children('.cloned').remove();\n                    this._clones = [];\n                }\n            }\n        },\n        {\n            filter: ['items', 'settings'],\n            run: function () {\n                var i, n,\n                    clones = this._clones,\n                    items = this._items,\n                    delta = this.settings.loop ? clones.length - Math.max(this.settings.items * 2, 4) : 0;\n\n                for (i = 0, n = Math.abs(delta / 2); i < n; i++) {\n                    if (delta > 0) {\n                        this.$stage.children().eq(items.length + clones.length - 1).remove();\n                        clones.pop();\n                        this.$stage.children().eq(0).remove();\n                        clones.pop();\n                    } else {\n                        clones.push(clones.length / 2);\n                        this.$stage.append(items[clones[clones.length - 1]].clone().addClass('cloned'));\n                        clones.push(items.length - 1 - (clones.length - 1) / 2);\n                        this.$stage.prepend(items[clones[clones.length - 1]].clone().addClass('cloned'));\n                    }\n                }\n            }\n        },\n        {\n            filter: ['width', 'items', 'settings'],\n            run: function () {\n                var rtl = (this.settings.rtl ? 1 : -1),\n                    width = (this.width() / this.settings.items).toFixed(3),\n                    coordinate = 0, merge, i, n;\n\n                this._coordinates = [];\n                for (i = 0, n = this._clones.length + this._items.length; i < n; i++) {\n                    merge = this._mergers[this.relative(i)];\n                    merge = (this.settings.mergeFit && Math.min(merge, this.settings.items)) || merge;\n                    coordinate += (this.settings.autoWidth ? this._items[this.relative(i)].width() + this.settings.margin : width * merge) * rtl;\n\n                    this._coordinates.push(coordinate);\n                }\n            }\n        },\n        {\n            filter: ['width', 'items', 'settings'],\n            run: function () {\n                var i, n, width = (this.width() / this.settings.items).toFixed(3), css = {\n                    'width': Math.abs(this._coordinates[this._coordinates.length - 1]) + this.settings.stagePadding * 2,\n                    'padding-left': this.settings.stagePadding || '',\n                    'padding-right': this.settings.stagePadding || ''\n                };\n\n                this.$stage.css(css);\n\n                css = {'width': this.settings.autoWidth ? 'auto' : width - this.settings.margin};\n                css[this.settings.rtl ? 'margin-left' : 'margin-right'] = this.settings.margin;\n\n                if (!this.settings.autoWidth && $.grep(this._mergers, function (v) {\n                        return v > 1\n                    }).length > 0) {\n                    for (i = 0, n = this._coordinates.length; i < n; i++) {\n                        css.width = Math.abs(this._coordinates[i]) - Math.abs(this._coordinates[i - 1] || 0) - this.settings.margin;\n                        this.$stage.children().eq(i).css(css);\n                    }\n                } else {\n                    this.$stage.children().css(css);\n                }\n            }\n        },\n        {\n            filter: ['width', 'items', 'settings'],\n            run: function (cache) {\n                cache.current && this.reset(this.$stage.children().index(cache.current));\n            }\n        },\n        {\n            filter: ['position'],\n            run: function () {\n                this.animate(this.coordinates(this._current));\n            }\n        },\n        {\n            filter: ['width', 'position', 'items', 'settings'],\n            run: function () {\n                var rtl = this.settings.rtl ? 1 : -1,\n                    padding = this.settings.stagePadding * 2,\n                    begin = this.coordinates(this.current()) + padding,\n                    end = begin + this.width() * rtl,\n                    inner, outer, matches = [], i, n;\n\n                for (i = 0, n = this._coordinates.length; i < n; i++) {\n                    inner = this._coordinates[i - 1] || 0;\n                    outer = Math.abs(this._coordinates[i]) + padding * rtl;\n\n                    if ((this.op(inner, '<=', begin) && (this.op(inner, '>', end)))\n                        || (this.op(outer, '<', begin) && this.op(outer, '>', end))) {\n                        matches.push(i);\n                    }\n                }\n\n                this.$stage.children('.' + this.settings.activeClass).removeClass(this.settings.activeClass);\n                this.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass(this.settings.activeClass);\n\n                if (this.settings.center) {\n                    this.$stage.children('.' + this.settings.centerClass).removeClass(this.settings.centerClass);\n                    this.$stage.children().eq(this.current()).addClass(this.settings.centerClass);\n                }\n            }\n        }\n    ];\n\n    /**\n     * Initializes the carousel.\n     * @protected\n     */\n    Owl.prototype.initialize = function () {\n        this.trigger('initialize');\n\n        this.$element\n            .addClass(this.settings.baseClass)\n            .addClass(this.settings.themeClass)\n            .toggleClass('owl-rtl', this.settings.rtl);\n\n        // check support\n        this.browserSupport();\n\n        if (this.settings.autoWidth && this.state.imagesLoaded !== true) {\n            var imgs, nestedSelector, width;\n            imgs = this.$element.find('img');\n            nestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;\n            width = this.$element.children(nestedSelector).width();\n\n            if (imgs.length && width <= 0) {\n                this.preloadAutoWidthImages(imgs);\n                return false;\n            }\n        }\n\n        this.$element.addClass('owl-loading');\n\n        // create stage\n        this.$stage = $('<' + this.settings.stageElement + ' class=\"owl-stage\"/>')\n            .wrap('<div class=\"owl-stage-outer\">');\n\n        // append stage\n        this.$element.append(this.$stage.parent());\n\n        // append content\n        this.replace(this.$element.children().not(this.$stage.parent()));\n\n        // set view width\n        this._width = this.$element.width();\n\n        // update view\n        this.refresh();\n\n        this.$element.removeClass('owl-loading').addClass('owl-loaded');\n\n        // attach generic events\n        this.eventsCall();\n\n        // attach generic events\n        this.internalEvents();\n\n        // attach custom control events\n        this.addTriggerableEvents();\n\n        this.trigger('initialized');\n    };\n\n    /**\n     * Setups the current settings.\n     * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?\n     * @todo Support for media queries by using `matchMedia` would be nice.\n     * @public\n     */\n    Owl.prototype.setup = function () {\n        var viewport = this.viewport(),\n            overwrites = this.options.responsive,\n            match = -1,\n            settings = null;\n\n        if (!overwrites) {\n            settings = $.extend({}, this.options);\n        } else {\n            $.each(overwrites, function (breakpoint) {\n                if (breakpoint <= viewport && breakpoint > match) {\n                    match = Number(breakpoint);\n                }\n            });\n\n            settings = $.extend({}, this.options, overwrites[match]);\n            delete settings.responsive;\n\n            // responsive class\n            if (settings.responsiveClass) {\n                this.$element.attr('class', function (i, c) {\n                    return c.replace(/\\b owl-responsive-\\S+/g, '');\n                }).addClass('owl-responsive-' + match);\n            }\n        }\n\n        if (this.settings === null || this._breakpoint !== match) {\n            this.trigger('change', {property: {name: 'settings', value: settings}});\n            this._breakpoint = match;\n            this.settings = settings;\n            this.invalidate('settings');\n            this.trigger('changed', {property: {name: 'settings', value: this.settings}});\n        }\n    };\n\n    /**\n     * Updates option logic if necessery.\n     * @protected\n     */\n    Owl.prototype.optionsLogic = function () {\n        // Toggle Center class\n        this.$element.toggleClass('owl-center', this.settings.center);\n\n        // if items number is less than in body\n        if (this.settings.loop && this._items.length < this.settings.items) {\n            this.settings.loop = false;\n        }\n\n        if (this.settings.autoWidth) {\n            this.settings.stagePadding = false;\n            this.settings.merge = false;\n        }\n    };\n\n    /**\n     * Prepares an item before add.\n     * @todo Rename event parameter `content` to `item`.\n     * @protected\n     * @returns {jQuery|HTMLElement} - The item container.\n     */\n    Owl.prototype.prepare = function (item) {\n        var event = this.trigger('prepare', {content: item});\n\n        if (!event.data) {\n            event.data = $('<' + this.settings.itemElement + '/>')\n                .addClass(this.settings.itemClass).append(item)\n        }\n\n        this.trigger('prepared', {content: event.data});\n\n        return event.data;\n    };\n\n    /**\n     * Updates the view.\n     * @public\n     */\n    Owl.prototype.update = function () {\n        var i = 0,\n            n = this._pipe.length,\n            filter = $.proxy(function (p) {\n                return this[p]\n            }, this._invalidated),\n            cache = {};\n\n        while (i < n) {\n            if (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {\n                this._pipe[i].run(cache);\n            }\n            i++;\n        }\n\n        this._invalidated = {};\n    };\n\n    /**\n     * Gets the width of the view.\n     * @public\n     * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.\n     * @returns {Number} - The width of the view in pixel.\n     */\n    Owl.prototype.width = function (dimension) {\n        dimension = dimension || Owl.Width.Default;\n        switch (dimension) {\n            case Owl.Width.Inner:\n            case Owl.Width.Outer:\n                return this._width;\n            default:\n                return this._width - this.settings.stagePadding * 2 + this.settings.margin;\n        }\n    };\n\n    /**\n     * Refreshes the carousel primarily for adaptive purposes.\n     * @public\n     */\n    Owl.prototype.refresh = function () {\n        if (this._items.length === 0) {\n            return false;\n        }\n\n        var start = new Date().getTime();\n\n        this.trigger('refresh');\n\n        this.setup();\n\n        this.optionsLogic();\n\n        // hide and show methods helps here to set a proper widths,\n        // this prevents scrollbar to be calculated in stage width\n        this.$stage.addClass('owl-refresh');\n\n        this.update();\n\n        this.$stage.removeClass('owl-refresh');\n\n        this.state.orientation = window.orientation;\n\n        this.watchVisibility();\n\n        this.trigger('refreshed');\n    };\n\n    /**\n     * Save internal event references and add event based functions.\n     * @protected\n     */\n    Owl.prototype.eventsCall = function () {\n        // Save events references\n        this.e._onDragStart = $.proxy(function (e) {\n            this.onDragStart(e);\n        }, this);\n        this.e._onDragMove = $.proxy(function (e) {\n            this.onDragMove(e);\n        }, this);\n        this.e._onDragEnd = $.proxy(function (e) {\n            this.onDragEnd(e);\n        }, this);\n        this.e._onResize = $.proxy(function (e) {\n            this.onResize(e);\n        }, this);\n        this.e._transitionEnd = $.proxy(function (e) {\n            this.transitionEnd(e);\n        }, this);\n        this.e._preventClick = $.proxy(function (e) {\n            this.preventClick(e);\n        }, this);\n    };\n\n    /**\n     * Checks window `resize` event.\n     * @protected\n     */\n    Owl.prototype.onThrottledResize = function () {\n        window.clearTimeout(this.resizeTimer);\n        this.resizeTimer = window.setTimeout(this.e._onResize, this.settings.responsiveRefreshRate);\n    };\n\n    /**\n     * Checks window `resize` event.\n     * @protected\n     */\n    Owl.prototype.onResize = function () {\n        if (!this._items.length) {\n            return false;\n        }\n\n        if (this._width === this.$element.width()) {\n            return false;\n        }\n\n        if (this.trigger('resize').isDefaultPrevented()) {\n            return false;\n        }\n\n        this._width = this.$element.width();\n\n        this.invalidate('width');\n\n        this.refresh();\n\n        this.trigger('resized');\n    };\n\n    /**\n     * Checks for touch/mouse drag event type and add run event handlers.\n     * @protected\n     */\n    Owl.prototype.eventsRouter = function (event) {\n        var type = event.type;\n\n        if (type === \"mousedown\" || type === \"touchstart\") {\n            this.onDragStart(event);\n        } else if (type === \"mousemove\" || type === \"touchmove\") {\n            this.onDragMove(event);\n        } else if (type === \"mouseup\" || type === \"touchend\") {\n            this.onDragEnd(event);\n        } else if (type === \"touchcancel\") {\n            this.onDragEnd(event);\n        }\n    };\n\n    /**\n     * Checks for touch/mouse drag options and add necessery event handlers.\n     * @protected\n     */\n    Owl.prototype.internalEvents = function () {\n        var isTouch = isTouchSupport(),\n            isTouchIE = isTouchSupportIE();\n\n        if (this.settings.mouseDrag) {\n            this.$stage.on('mousedown', $.proxy(function (event) {\n                this.eventsRouter(event)\n            }, this));\n            this.$stage.on('dragstart', function () {\n                return false\n            });\n            this.$stage.get(0).onselectstart = function () {\n                return false\n            };\n        } else {\n            this.$element.addClass('owl-text-select-on');\n        }\n\n        if (this.settings.touchDrag && !isTouchIE) {\n            this.$stage.on('touchstart touchcancel', $.proxy(function (event) {\n                this.eventsRouter(event)\n            }, this));\n        }\n\n        // catch transitionEnd event\n        if (this.transitionEndVendor) {\n            this.on(this.$stage.get(0), this.transitionEndVendor, this.e._transitionEnd, false);\n        }\n\n        // responsive\n        if (this.settings.responsive !== false) {\n            this.on(window, 'resize', $.proxy(this.onThrottledResize, this));\n        }\n    };\n\n    /**\n     * Handles touchstart/mousedown event.\n     * @protected\n     * @param {Event} event - The event arguments.\n     */\n    Owl.prototype.onDragStart = function (event) {\n        var ev, isTouchEvent, pageX, pageY, animatedPos;\n\n        ev = event.originalEvent || event || window.event;\n\n        // prevent right click\n        if (ev.which === 3 || this.state.isTouch) {\n            return false;\n        }\n\n        if (ev.type === 'mousedown') {\n            this.$stage.addClass('owl-grab');\n        }\n\n        this.trigger('drag');\n        this.drag.startTime = new Date().getTime();\n        this.speed(0);\n        this.state.isTouch = true;\n        this.state.isScrolling = false;\n        this.state.isSwiping = false;\n        this.drag.distance = 0;\n\n        pageX = getTouches(ev).x;\n        pageY = getTouches(ev).y;\n\n        // get stage position left\n        this.drag.offsetX = this.$stage.position().left;\n        this.drag.offsetY = this.$stage.position().top;\n\n        if (this.settings.rtl) {\n            this.drag.offsetX = this.$stage.position().left + this.$stage.width() - this.width()\n            + this.settings.margin;\n        }\n\n        // catch position // ie to fix\n        if (this.state.inMotion && this.support3d) {\n            animatedPos = this.getTransformProperty();\n            this.drag.offsetX = animatedPos;\n            this.animate(animatedPos);\n            this.state.inMotion = true;\n        } else if (this.state.inMotion && !this.support3d) {\n            this.state.inMotion = false;\n            return false;\n        }\n\n        this.drag.startX = pageX - this.drag.offsetX;\n        this.drag.startY = pageY - this.drag.offsetY;\n\n        this.drag.start = pageX - this.drag.startX;\n        this.drag.targetEl = ev.target || ev.srcElement;\n        this.drag.updatedX = this.drag.start;\n\n        // to do/check\n        // prevent links and images dragging;\n        if (this.drag.targetEl.tagName === \"IMG\" || this.drag.targetEl.tagName === \"A\") {\n            this.drag.targetEl.draggable = false;\n        }\n\n        $(document).on('mousemove.owl.dragEvents mouseup.owl.dragEvents touchmove.owl.dragEvents touchend.owl.dragEvents', $.proxy(function (event) {\n            this.eventsRouter(event)\n        }, this));\n    };\n\n    /**\n     * Handles the touchmove/mousemove events.\n     * @todo Simplify\n     * @protected\n     * @param {Event} event - The event arguments.\n     */\n    Owl.prototype.onDragMove = function (event) {\n        var ev, isTouchEvent, pageX, pageY, minValue, maxValue, pull;\n\n        if (!this.state.isTouch) {\n            return;\n        }\n\n        if (this.state.isScrolling) {\n            return;\n        }\n\n        ev = event.originalEvent || event || window.event;\n\n        pageX = getTouches(ev).x;\n        pageY = getTouches(ev).y;\n\n        // Drag Direction\n        this.drag.currentX = pageX - this.drag.startX;\n        this.drag.currentY = pageY - this.drag.startY;\n        this.drag.distance = this.drag.currentX - this.drag.offsetX;\n\n        // Check move direction\n        if (this.drag.distance < 0) {\n            this.state.direction = this.settings.rtl ? 'right' : 'left';\n        } else if (this.drag.distance > 0) {\n            this.state.direction = this.settings.rtl ? 'left' : 'right';\n        }\n        // Loop\n        if (this.settings.loop) {\n            if (this.op(this.drag.currentX, '>', this.coordinates(this.minimum())) && this.state.direction === 'right') {\n                this.drag.currentX -= (this.settings.center && this.coordinates(0)) - this.coordinates(this._items.length);\n            } else if (this.op(this.drag.currentX, '<', this.coordinates(this.maximum())) && this.state.direction === 'left') {\n                this.drag.currentX += (this.settings.center && this.coordinates(0)) - this.coordinates(this._items.length);\n            }\n        } else {\n            // pull\n            minValue = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());\n            maxValue = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());\n            pull = this.settings.pullDrag ? this.drag.distance / 5 : 0;\n            this.drag.currentX = Math.max(Math.min(this.drag.currentX, minValue + pull), maxValue + pull);\n        }\n\n        // Lock browser if swiping horizontal\n\n        if ((this.drag.distance > 8 || this.drag.distance < -8)) {\n            if (ev.preventDefault !== undefined) {\n                ev.preventDefault();\n            } else {\n                ev.returnValue = false;\n            }\n            this.state.isSwiping = true;\n        }\n\n        this.drag.updatedX = this.drag.currentX;\n\n        // Lock Owl if scrolling\n        if ((this.drag.currentY > 16 || this.drag.currentY < -16) && this.state.isSwiping === false) {\n            this.state.isScrolling = true;\n            this.drag.updatedX = this.drag.start;\n        }\n\n        this.animate(this.drag.updatedX);\n    };\n\n    /**\n     * Handles the touchend/mouseup events.\n     * @protected\n     */\n    Owl.prototype.onDragEnd = function (event) {\n        var compareTimes, distanceAbs, closest;\n\n        if (!this.state.isTouch) {\n            return;\n        }\n\n        if (event.type === 'mouseup') {\n            this.$stage.removeClass('owl-grab');\n        }\n\n        this.trigger('dragged');\n\n        // prevent links and images dragging;\n        this.drag.targetEl.removeAttribute(\"draggable\");\n\n        // remove drag event listeners\n\n        this.state.isTouch = false;\n        this.state.isScrolling = false;\n        this.state.isSwiping = false;\n\n        // to check\n        if (this.drag.distance === 0 && this.state.inMotion !== true) {\n            this.state.inMotion = false;\n            return false;\n        }\n\n        // prevent clicks while scrolling\n\n        this.drag.endTime = new Date().getTime();\n        compareTimes = this.drag.endTime - this.drag.startTime;\n        distanceAbs = Math.abs(this.drag.distance);\n\n        // to test\n        if (distanceAbs > 3 || compareTimes > 300) {\n            this.removeClick(this.drag.targetEl);\n        }\n\n        closest = this.closest(this.drag.updatedX);\n\n        this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);\n        this.current(closest);\n        this.invalidate('position');\n        this.update();\n\n        // if pullDrag is off then fire transitionEnd event manually when stick\n        // to border\n        if (!this.settings.pullDrag && this.drag.updatedX === this.coordinates(closest)) {\n            this.transitionEnd();\n        }\n\n        this.drag.distance = 0;\n\n        $(document).off('.owl.dragEvents');\n    };\n\n    /**\n     * Attaches `preventClick` to disable link while swipping.\n     * @protected\n     * @param {HTMLElement} [target] - The target of the `click` event.\n     */\n    Owl.prototype.removeClick = function (target) {\n        this.drag.targetEl = target;\n        $(target).on('click.preventClick', this.e._preventClick);\n        // to make sure click is removed:\n        window.setTimeout(function () {\n            $(target).off('click.preventClick');\n        }, 300);\n    };\n\n    /**\n     * Suppresses click event.\n     * @protected\n     * @param {Event} ev - The event arguments.\n     */\n    Owl.prototype.preventClick = function (ev) {\n        if (ev.preventDefault) {\n            ev.preventDefault();\n        } else {\n            ev.returnValue = false;\n        }\n        if (ev.stopPropagation) {\n            ev.stopPropagation();\n        }\n        $(ev.target).off('click.preventClick');\n    };\n\n    /**\n     * Catches stage position while animate (only CSS3).\n     * @protected\n     * @returns\n     */\n    Owl.prototype.getTransformProperty = function () {\n        var transform, matrix3d;\n\n        transform = window.getComputedStyle(this.$stage.get(0), null).getPropertyValue(this.vendorName + 'transform');\n        // var transform = this.$stage.css(this.vendorName + 'transform')\n        transform = transform.replace(/matrix(3d)?\\(|\\)/g, '').split(',');\n        matrix3d = transform.length === 16;\n\n        return matrix3d !== true ? transform[4] : transform[12];\n    };\n\n    /**\n     * Gets absolute position of the closest item for a coordinate.\n     * @todo Setting `freeDrag` makes `closest` not reusable. See #165.\n     * @protected\n     * @param {Number} coordinate - The coordinate in pixel.\n     * @return {Number} - The absolute position of the closest item.\n     */\n    Owl.prototype.closest = function (coordinate) {\n        var position = -1, pull = 30, width = this.width(), coordinates = this.coordinates();\n\n        if (!this.settings.freeDrag) {\n            // check closest item\n            $.each(coordinates, $.proxy(function (index, value) {\n                if (coordinate > value - pull && coordinate < value + pull) {\n                    position = index;\n                } else if (this.op(coordinate, '<', value)\n                    && this.op(coordinate, '>', coordinates[index + 1] || value - width)) {\n                    position = this.state.direction === 'left' ? index + 1 : index;\n                }\n                return position === -1;\n            }, this));\n        }\n\n        if (!this.settings.loop) {\n            // non loop boundries\n            if (this.op(coordinate, '>', coordinates[this.minimum()])) {\n                position = coordinate = this.minimum();\n            } else if (this.op(coordinate, '<', coordinates[this.maximum()])) {\n                position = coordinate = this.maximum();\n            }\n        }\n\n        return position;\n    };\n\n    /**\n     * Animates the stage.\n     * @public\n     * @param {Number} coordinate - The coordinate in pixels.\n     */\n    Owl.prototype.animate = function (coordinate) {\n        this.trigger('translating');\n        this.state.inMotion = this.speed() > 0;\n\n        if (this.support3d) {\n            this.$stage.css({\n                transform: 'translate3d(' + coordinate + 'px' + ',0px, 0px)',\n                transition: (this.speed() / 1000) + 's'\n            });\n        } else if (this.state.isTouch) {\n            this.$stage.css({\n                left: coordinate + 'px'\n            });\n        } else {\n            this.$stage.animate({\n                left: coordinate\n            }, this.speed() / 1000, this.settings.fallbackEasing, $.proxy(function () {\n                if (this.state.inMotion) {\n                    this.transitionEnd();\n                }\n            }, this));\n        }\n    };\n\n    /**\n     * Sets the absolute position of the current item.\n     * @public\n     * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.\n     * @returns {Number} - The absolute position of the current item.\n     */\n    Owl.prototype.current = function (position) {\n        if (position === undefined) {\n            return this._current;\n        }\n\n        if (this._items.length === 0) {\n            return undefined;\n        }\n\n        position = this.normalize(position);\n\n        if (this._current !== position) {\n            var event = this.trigger('change', {property: {name: 'position', value: position}});\n\n            if (event.data !== undefined) {\n                position = this.normalize(event.data);\n            }\n\n            this._current = position;\n\n            this.invalidate('position');\n\n            this.trigger('changed', {property: {name: 'position', value: this._current}});\n        }\n\n        return this._current;\n    };\n\n    /**\n     * Invalidates the given part of the update routine.\n     * @param {String} part - The part to invalidate.\n     */\n    Owl.prototype.invalidate = function (part) {\n        this._invalidated[part] = true;\n    }\n\n    /**\n     * Resets the absolute position of the current item.\n     * @public\n     * @param {Number} position - The absolute position of the new item.\n     */\n    Owl.prototype.reset = function (position) {\n        position = this.normalize(position);\n\n        if (position === undefined) {\n            return;\n        }\n\n        this._speed = 0;\n        this._current = position;\n\n        this.suppress(['translating', 'translated']);\n\n        this.animate(this.coordinates(position));\n\n        this.release(['translating', 'translated']);\n    };\n\n    /**\n     * Normalizes an absolute or a relative position for an item.\n     * @public\n     * @param {Number} position - The absolute or relative position to normalize.\n     * @param {Boolean} [relative=false] - Whether the given position is relative or not.\n     * @returns {Number} - The normalized position.\n     */\n    Owl.prototype.normalize = function (position, relative) {\n        var n = (relative ? this._items.length : this._items.length + this._clones.length);\n\n        if (!$.isNumeric(position) || n < 1) {\n            return undefined;\n        }\n\n        if (this._clones.length) {\n            position = ((position % n) + n) % n;\n        } else {\n            position = Math.max(this.minimum(relative), Math.min(this.maximum(relative), position));\n        }\n\n        return position;\n    };\n\n    /**\n     * Converts an absolute position for an item into a relative position.\n     * @public\n     * @param {Number} position - The absolute position to convert.\n     * @returns {Number} - The converted position.\n     */\n    Owl.prototype.relative = function (position) {\n        position = this.normalize(position);\n        position = position - this._clones.length / 2;\n        return this.normalize(position, true);\n    };\n\n    /**\n     * Gets the maximum position for an item.\n     * @public\n     * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n     * @returns {Number}\n     */\n    Owl.prototype.maximum = function (relative) {\n        var maximum, width, i = 0, coordinate,\n            settings = this.settings;\n\n        if (relative) {\n            return this._items.length - 1;\n        }\n\n        if (!settings.loop && settings.center) {\n            maximum = this._items.length - 1;\n        } else if (!settings.loop && !settings.center) {\n            maximum = this._items.length - settings.items;\n        } else if (settings.loop || settings.center) {\n            maximum = this._items.length + settings.items;\n        } else if (settings.autoWidth || settings.merge) {\n            revert = settings.rtl ? 1 : -1;\n            width = this.$stage.width() - this.$element.width();\n            while (coordinate = this.coordinates(i)) {\n                if (coordinate * revert >= width) {\n                    break;\n                }\n                maximum = ++i;\n            }\n        } else {\n            throw 'Can not detect maximum absolute position.'\n        }\n\n        return maximum;\n    };\n\n    /**\n     * Gets the minimum position for an item.\n     * @public\n     * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n     * @returns {Number}\n     */\n    Owl.prototype.minimum = function (relative) {\n        if (relative) {\n            return 0;\n        }\n\n        return this._clones.length / 2;\n    };\n\n    /**\n     * Gets an item at the specified relative position.\n     * @public\n     * @param {Number} [position] - The relative position of the item.\n     * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n     */\n    Owl.prototype.items = function (position) {\n        if (position === undefined) {\n            return this._items.slice();\n        }\n\n        position = this.normalize(position, true);\n        return this._items[position];\n    };\n\n    /**\n     * Gets an item at the specified relative position.\n     * @public\n     * @param {Number} [position] - The relative position of the item.\n     * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n     */\n    Owl.prototype.mergers = function (position) {\n        if (position === undefined) {\n            return this._mergers.slice();\n        }\n\n        position = this.normalize(position, true);\n        return this._mergers[position];\n    };\n\n    /**\n     * Gets the absolute positions of clones for an item.\n     * @public\n     * @param {Number} [position] - The relative position of the item.\n     * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.\n     */\n    Owl.prototype.clones = function (position) {\n        var odd = this._clones.length / 2,\n            even = odd + this._items.length,\n            map = function (index) {\n                return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2\n            };\n\n        if (position === undefined) {\n            return $.map(this._clones, function (v, i) {\n                return map(i)\n            });\n        }\n\n        return $.map(this._clones, function (v, i) {\n            return v === position ? map(i) : null\n        });\n    };\n\n    /**\n     * Sets the current animation speed.\n     * @public\n     * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.\n     * @returns {Number} - The current animation speed in milliseconds.\n     */\n    Owl.prototype.speed = function (speed) {\n        if (speed !== undefined) {\n            this._speed = speed;\n        }\n\n        return this._speed;\n    };\n\n    /**\n     * Gets the coordinate of an item.\n     * @todo The name of this method is missleanding.\n     * @public\n     * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.\n     * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.\n     */\n    Owl.prototype.coordinates = function (position) {\n        var coordinate = null;\n\n        if (position === undefined) {\n            return $.map(this._coordinates, $.proxy(function (coordinate, index) {\n                return this.coordinates(index);\n            }, this));\n        }\n\n        if (this.settings.center) {\n            coordinate = this._coordinates[position];\n            coordinate += (this.width() - coordinate + (this._coordinates[position - 1] || 0)) / 2 * (this.settings.rtl ? -1 : 1);\n        } else {\n            coordinate = this._coordinates[position - 1] || 0;\n        }\n\n        return coordinate;\n    };\n\n    /**\n     * Calculates the speed for a translation.\n     * @protected\n     * @param {Number} from - The absolute position of the start item.\n     * @param {Number} to - The absolute position of the target item.\n     * @param {Number} [factor=undefined] - The time factor in milliseconds.\n     * @returns {Number} - The time in milliseconds for the translation.\n     */\n    Owl.prototype.duration = function (from, to, factor) {\n        return Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs((factor || this.settings.smartSpeed));\n    };\n\n    /**\n     * Slides to the specified item.\n     * @public\n     * @param {Number} position - The position of the item.\n     * @param {Number} [speed] - The time in milliseconds for the transition.\n     */\n    Owl.prototype.to = function (position, speed) {\n        if (this.settings.loop) {\n            var distance = position - this.relative(this.current()),\n                revert = this.current(),\n                before = this.current(),\n                after = this.current() + distance,\n                direction = before - after < 0 ? true : false,\n                items = this._clones.length + this._items.length;\n\n            if (after < this.settings.items && direction === false) {\n                revert = before + this._items.length;\n                this.reset(revert);\n            } else if (after >= items - this.settings.items && direction === true) {\n                revert = before - this._items.length;\n                this.reset(revert);\n            }\n            window.clearTimeout(this.e._goToLoop);\n            this.e._goToLoop = window.setTimeout($.proxy(function () {\n                this.speed(this.duration(this.current(), revert + distance, speed));\n                this.current(revert + distance);\n                this.update();\n            }, this), 30);\n        } else {\n            this.speed(this.duration(this.current(), position, speed));\n            this.current(position);\n            this.update();\n        }\n    };\n\n    /**\n     * Slides to the next item.\n     * @public\n     * @param {Number} [speed] - The time in milliseconds for the transition.\n     */\n    Owl.prototype.next = function (speed) {\n        speed = speed || false;\n        this.to(this.relative(this.current()) + 1, speed);\n    };\n\n    /**\n     * Slides to the previous item.\n     * @public\n     * @param {Number} [speed] - The time in milliseconds for the transition.\n     */\n    Owl.prototype.prev = function (speed) {\n        speed = speed || false;\n        this.to(this.relative(this.current()) - 1, speed);\n    };\n\n    /**\n     * Handles the end of an animation.\n     * @protected\n     * @param {Event} event - The event arguments.\n     */\n    Owl.prototype.transitionEnd = function (event) {\n\n        // if css2 animation then event object is undefined\n        if (event !== undefined) {\n            event.stopPropagation();\n\n            // Catch only owl-stage transitionEnd event\n            if ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {\n                return false;\n            }\n        }\n\n        this.state.inMotion = false;\n        this.trigger('translated');\n    };\n\n    /**\n     * Gets viewport width.\n     * @protected\n     * @return {Number} - The width in pixel.\n     */\n    Owl.prototype.viewport = function () {\n        var width;\n        if (this.options.responsiveBaseElement !== window) {\n            width = $(this.options.responsiveBaseElement).width();\n        } else if (window.innerWidth) {\n            width = window.innerWidth;\n        } else if (document.documentElement && document.documentElement.clientWidth) {\n            width = document.documentElement.clientWidth;\n        } else {\n            throw 'Can not detect viewport width.';\n        }\n        return width;\n    };\n\n    /**\n     * Replaces the current content.\n     * @public\n     * @param {HTMLElement|jQuery|String} content - The new content.\n     */\n    Owl.prototype.replace = function (content) {\n        this.$stage.empty();\n        this._items = [];\n\n        if (content) {\n            content = (content instanceof jQuery) ? content : $(content);\n        }\n\n        if (this.settings.nestedItemSelector) {\n            content = content.find('.' + this.settings.nestedItemSelector);\n        }\n\n        content.filter(function () {\n            return this.nodeType === 1;\n        }).each($.proxy(function (index, item) {\n            item = this.prepare(item);\n            this.$stage.append(item);\n            this._items.push(item);\n            this._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n        }, this));\n\n        this.reset($.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);\n\n        this.invalidate('items');\n    };\n\n    /**\n     * Adds an item.\n     * @todo Use `item` instead of `content` for the event arguments.\n     * @public\n     * @param {HTMLElement|jQuery|String} content - The item content to add.\n     * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.\n     */\n    Owl.prototype.add = function (content, position) {\n        position = position === undefined ? this._items.length : this.normalize(position, true);\n\n        this.trigger('add', {content: content, position: position});\n\n        if (this._items.length === 0 || position === this._items.length) {\n            this.$stage.append(content);\n            this._items.push(content);\n            this._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n        } else {\n            this._items[position].before(content);\n            this._items.splice(position, 0, content);\n            this._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n        }\n\n        this.invalidate('items');\n\n        this.trigger('added', {content: content, position: position});\n    };\n\n    /**\n     * Removes an item by its position.\n     * @todo Use `item` instead of `content` for the event arguments.\n     * @public\n     * @param {Number} position - The relative position of the item to remove.\n     */\n    Owl.prototype.remove = function (position) {\n        position = this.normalize(position, true);\n\n        if (position === undefined) {\n            return;\n        }\n\n        this.trigger('remove', {content: this._items[position], position: position});\n\n        this._items[position].remove();\n        this._items.splice(position, 1);\n        this._mergers.splice(position, 1);\n\n        this.invalidate('items');\n\n        this.trigger('removed', {content: null, position: position});\n    };\n\n    /**\n     * Adds triggerable events.\n     * @protected\n     */\n    Owl.prototype.addTriggerableEvents = function () {\n        var handler = $.proxy(function (callback, event) {\n            return $.proxy(function (e) {\n                if (e.relatedTarget !== this) {\n                    this.suppress([event]);\n                    callback.apply(this, [].slice.call(arguments, 1));\n                    this.release([event]);\n                }\n            }, this);\n        }, this);\n\n        $.each({\n            'next': this.next,\n            'prev': this.prev,\n            'to': this.to,\n            'destroy': this.destroy,\n            'refresh': this.refresh,\n            'replace': this.replace,\n            'add': this.add,\n            'remove': this.remove\n        }, $.proxy(function (event, callback) {\n            this.$element.on(event + '.owl.carousel', handler(callback, event + '.owl.carousel'));\n        }, this));\n\n    };\n\n    /**\n     * Watches the visibility of the carousel element.\n     * @protected\n     */\n    Owl.prototype.watchVisibility = function () {\n\n        // test on zepto\n        if (!isElVisible(this.$element.get(0))) {\n            this.$element.addClass('owl-hidden');\n            window.clearInterval(this.e._checkVisibile);\n            this.e._checkVisibile = window.setInterval($.proxy(checkVisible, this), 500);\n        }\n\n        function isElVisible(el) {\n            return el.offsetWidth > 0 && el.offsetHeight > 0;\n        }\n\n        function checkVisible() {\n            if (isElVisible(this.$element.get(0))) {\n                this.$element.removeClass('owl-hidden');\n                this.refresh();\n                window.clearInterval(this.e._checkVisibile);\n            }\n\n        }\n    };\n\n    /**\n     * Preloads images with auto width.\n     * @protected\n     * @todo Still to test\n     */\n    Owl.prototype.preloadAutoWidthImages = function (imgs) {\n        var loaded, that, $el, img;\n\n        loaded = 0;\n        that = this;\n        imgs.each(function (i, el) {\n            $el = $(el);\n            img = new Image();\n\n            img.onload = function () {\n                loaded++;\n                $el.attr('src', img.src);\n                $el.css('opacity', 1);\n                if (loaded >= imgs.length) {\n                    that.state.imagesLoaded = true;\n                    that.initialize();\n                }\n            };\n\n            img.src = $el.attr('src') || $el.attr('data-src') || $el.attr('data-src-retina');\n        });\n    };\n\n    /**\n     * Destroys the carousel.\n     * @public\n     */\n    Owl.prototype.destroy = function () {\n\n        if (this.$element.hasClass(this.settings.themeClass)) {\n            this.$element.removeClass(this.settings.themeClass);\n        }\n\n        if (this.settings.responsive !== false) {\n            $(window).off('resize.owl.carousel');\n        }\n\n        if (this.transitionEndVendor) {\n            this.off(this.$stage.get(0), this.transitionEndVendor, this.e._transitionEnd);\n        }\n\n        for (var i in this._plugins) {\n            this._plugins[i].destroy();\n        }\n\n        if (this.settings.mouseDrag || this.settings.touchDrag) {\n            this.$stage.off('mousedown touchstart touchcancel');\n            $(document).off('.owl.dragEvents');\n            this.$stage.get(0).onselectstart = function () {\n            };\n            this.$stage.off('dragstart', function () {\n                return false\n            });\n        }\n\n        // remove event handlers in the \".owl.carousel\" namespace\n        this.$element.off('.owl');\n\n        this.$stage.children('.cloned').remove();\n        this.e = null;\n        this.$element.removeData('owlCarousel');\n\n        this.$stage.children().contents().unwrap();\n        this.$stage.children().unwrap();\n        this.$stage.unwrap();\n    };\n\n    /**\n     * Operators to calculate right-to-left and left-to-right.\n     * @protected\n     * @param {Number} [a] - The left side operand.\n     * @param {String} [o] - The operator.\n     * @param {Number} [b] - The right side operand.\n     */\n    Owl.prototype.op = function (a, o, b) {\n        var rtl = this.settings.rtl;\n        switch (o) {\n            case '<':\n                return rtl ? a > b : a < b;\n            case '>':\n                return rtl ? a < b : a > b;\n            case '>=':\n                return rtl ? a <= b : a >= b;\n            case '<=':\n                return rtl ? a >= b : a <= b;\n            default:\n                break;\n        }\n    };\n\n    /**\n     * Attaches to an internal event.\n     * @protected\n     * @param {HTMLElement} element - The event source.\n     * @param {String} event - The event name.\n     * @param {Function} listener - The event handler to attach.\n     * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.\n     */\n    Owl.prototype.on = function (element, event, listener, capture) {\n        if (element.addEventListener) {\n            element.addEventListener(event, listener, capture);\n        } else if (element.attachEvent) {\n            element.attachEvent('on' + event, listener);\n        }\n    };\n\n    /**\n     * Detaches from an internal event.\n     * @protected\n     * @param {HTMLElement} element - The event source.\n     * @param {String} event - The event name.\n     * @param {Function} listener - The attached event handler to detach.\n     * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.\n     */\n    Owl.prototype.off = function (element, event, listener, capture) {\n        if (element.removeEventListener) {\n            element.removeEventListener(event, listener, capture);\n        } else if (element.detachEvent) {\n            element.detachEvent('on' + event, listener);\n        }\n    };\n\n    /**\n     * Triggers an public event.\n     * @protected\n     * @param {String} name - The event name.\n     * @param {*} [data=null] - The event data.\n     * @param {String} [namespace=.owl.carousel] - The event namespace.\n     * @returns {Event} - The event arguments.\n     */\n    Owl.prototype.trigger = function (name, data, namespace) {\n        var status = {\n            item: {count: this._items.length, index: this.current()}\n        }, handler = $.camelCase(\n            $.grep(['on', name, namespace], function (v) {\n                return v\n            })\n                .join('-').toLowerCase()\n        ), event = $.Event(\n            [name, 'owl', namespace || 'carousel'].join('.').toLowerCase(),\n            $.extend({relatedTarget: this}, status, data)\n        );\n\n        if (!this._supress[name]) {\n            $.each(this._plugins, function (name, plugin) {\n                if (plugin.onTrigger) {\n                    plugin.onTrigger(event);\n                }\n            });\n\n            this.$element.trigger(event);\n\n            if (this.settings && typeof this.settings[handler] === 'function') {\n                this.settings[handler].apply(this, event);\n            }\n        }\n\n        return event;\n    };\n\n    /**\n     * Suppresses events.\n     * @protected\n     * @param {Array.<String>} events - The events to suppress.\n     */\n    Owl.prototype.suppress = function (events) {\n        $.each(events, $.proxy(function (index, event) {\n            this._supress[event] = true;\n        }, this));\n    }\n\n    /**\n     * Releases suppressed events.\n     * @protected\n     * @param {Array.<String>} events - The events to release.\n     */\n    Owl.prototype.release = function (events) {\n        $.each(events, $.proxy(function (index, event) {\n            delete this._supress[event];\n        }, this));\n    }\n\n    /**\n     * Checks the availability of some browser features.\n     * @protected\n     */\n    Owl.prototype.browserSupport = function () {\n        this.support3d = isPerspective();\n\n        if (this.support3d) {\n            this.transformVendor = isTransform();\n\n            // take transitionend event name by detecting transition\n            var endVendors = ['transitionend', 'webkitTransitionEnd', 'transitionend', 'oTransitionEnd'];\n            this.transitionEndVendor = endVendors[isTransition()];\n\n            // take vendor name from transform name\n            this.vendorName = this.transformVendor.replace(/Transform/i, '');\n            this.vendorName = this.vendorName !== '' ? '-' + this.vendorName.toLowerCase() + '-' : '';\n        }\n\n        this.state.orientation = window.orientation;\n    };\n\n    /**\n     * Get touch/drag coordinats.\n     * @private\n     * @param {event} - mousedown/touchstart event\n     * @returns {object} - Contains X and Y of current mouse/touch position\n     */\n\n    function getTouches(event) {\n        if (event.touches !== undefined) {\n            return {\n                x: event.touches[0].pageX,\n                y: event.touches[0].pageY\n            };\n        }\n\n        if (event.touches === undefined) {\n            if (event.pageX !== undefined) {\n                return {\n                    x: event.pageX,\n                    y: event.pageY\n                };\n            }\n\n            if (event.pageX === undefined) {\n                return {\n                    x: event.clientX,\n                    y: event.clientY\n                };\n            }\n        }\n    }\n\n    /**\n     * Checks for CSS support.\n     * @private\n     * @param {Array} array - The CSS properties to check for.\n     * @returns {Array} - Contains the supported CSS property name and its index or `false`.\n     */\n    function isStyleSupported(array) {\n        var p, s, fake = document.createElement('div'), list = array;\n        for (p in list) {\n            s = list[p];\n            if (typeof fake.style[s] !== 'undefined') {\n                fake = null;\n                return [s, p];\n            }\n        }\n        return [false];\n    }\n\n    /**\n     * Checks for CSS transition support.\n     * @private\n     * @todo Realy bad design\n     * @returns {Number}\n     */\n    function isTransition() {\n        return isStyleSupported(['transition', 'WebkitTransition', 'MozTransition', 'OTransition'])[1];\n    }\n\n    /**\n     * Checks for CSS transform support.\n     * @private\n     * @returns {String} The supported property name or false.\n     */\n    function isTransform() {\n        return isStyleSupported(['transform', 'WebkitTransform', 'MozTransform', 'OTransform', 'msTransform'])[0];\n    }\n\n    /**\n     * Checks for CSS perspective support.\n     * @private\n     * @returns {String} The supported property name or false.\n     */\n    function isPerspective() {\n        return isStyleSupported(['perspective', 'webkitPerspective', 'MozPerspective', 'OPerspective', 'MsPerspective'])[0];\n    }\n\n    /**\n     * Checks wether touch is supported or not.\n     * @private\n     * @returns {Boolean}\n     */\n    function isTouchSupport() {\n        return 'ontouchstart' in window || !!(navigator.msMaxTouchPoints);\n    }\n\n    /**\n     * Checks wether touch is supported or not for IE.\n     * @private\n     * @returns {Boolean}\n     */\n    function isTouchSupportIE() {\n        return window.navigator.msPointerEnabled;\n    }\n\n    /**\n     * The jQuery Plugin for the Owl Carousel\n     * @public\n     */\n    $.fn.owlCarousel = function (options) {\n        return this.each(function () {\n            if (!$(this).data('owlCarousel')) {\n                $(this).data('owlCarousel', new Owl(this, options));\n            }\n        });\n    };\n\n    /**\n     * The constructor for the jQuery Plugin\n     * @public\n     */\n    $.fn.owlCarousel.Constructor = Owl;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Lazy Plugin\n * @version 2.0.0\n * @author Bartosz Wojciechowski\n * @license The MIT License (MIT)\n */\n;\n(function ($, window, document, undefined) {\n\n    /**\n     * Creates the lazy plugin.\n     * @class The Lazy Plugin\n     * @param {Owl} carousel - The Owl Carousel\n     */\n    var Lazy = function (carousel) {\n\n        /**\n         * Reference to the core.\n         * @protected\n         * @type {Owl}\n         */\n        this._core = carousel;\n\n        /**\n         * Already loaded items.\n         * @protected\n         * @type {Array.<jQuery>}\n         */\n        this._loaded = [];\n\n        /**\n         * Event handlers.\n         * @protected\n         * @type {Object}\n         */\n        this._handlers = {\n            'initialized.owl.carousel change.owl.carousel': $.proxy(function (e) {\n                if (!e.namespace) {\n                    return;\n                }\n\n                if (!this._core.settings || !this._core.settings.lazyLoad) {\n                    return;\n                }\n\n                if ((e.property && e.property.name == 'position') || e.type == 'initialized') {\n                    var settings = this._core.settings,\n                        n = (settings.center && Math.ceil(settings.items / 2) || settings.items),\n                        i = ((settings.center && n * -1) || 0),\n                        position = ((e.property && e.property.value) || this._core.current()) + i,\n                        clones = this._core.clones().length,\n                        load = $.proxy(function (i, v) {\n                            this.load(v)\n                        }, this);\n\n                    while (i++ < n) {\n                        this.load(clones / 2 + this._core.relative(position));\n                        clones && $.each(this._core.clones(this._core.relative(position++)), load);\n                    }\n                }\n            }, this)\n        };\n\n        // set the default options\n        this._core.options = $.extend({}, Lazy.Defaults, this._core.options);\n\n        // register event handler\n        this._core.$element.on(this._handlers);\n    }\n\n    /**\n     * Default options.\n     * @public\n     */\n    Lazy.Defaults = {\n        lazyLoad: false\n    }\n\n    /**\n     * Loads all resources of an item at the specified position.\n     * @param {Number} position - The absolute position of the item.\n     * @protected\n     */\n    Lazy.prototype.load = function (position) {\n        var $item = this._core.$stage.children().eq(position),\n            $elements = $item && $item.find('.owl-lazy');\n\n        if (!$elements || $.inArray($item.get(0), this._loaded) > -1) {\n            return;\n        }\n\n        $elements.each($.proxy(function (index, element) {\n            var $element = $(element), image,\n                url = (window.devicePixelRatio > 1 && $element.attr('data-src-retina')) || $element.attr('data-src');\n\n            this._core.trigger('load', {element: $element, url: url}, 'lazy');\n\n            if ($element.is('img')) {\n                $element.one('load.owl.lazy', $.proxy(function () {\n                    $element.css('opacity', 1);\n                    this._core.trigger('loaded', {element: $element, url: url}, 'lazy');\n                }, this)).attr('src', url);\n            } else {\n                image = new Image();\n                image.onload = $.proxy(function () {\n                    $element.css({\n                        'background-image': 'url(' + url + ')',\n                        'opacity': '1'\n                    });\n                    this._core.trigger('loaded', {element: $element, url: url}, 'lazy');\n                }, this);\n                image.src = url;\n            }\n        }, this));\n\n        this._loaded.push($item.get(0));\n    }\n\n    /**\n     * Destroys the plugin.\n     * @public\n     */\n    Lazy.prototype.destroy = function () {\n        var handler, property;\n\n        for (handler in this.handlers) {\n            this._core.$element.off(handler, this.handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    }\n\n    $.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * AutoHeight Plugin\n * @version 2.0.0\n * @author Bartosz Wojciechowski\n * @license The MIT License (MIT)\n */\n;\n(function ($, window, document, undefined) {\n\n    /**\n     * Creates the auto height plugin.\n     * @class The Auto Height Plugin\n     * @param {Owl} carousel - The Owl Carousel\n     */\n    var AutoHeight = function (carousel) {\n        /**\n         * Reference to the core.\n         * @protected\n         * @type {Owl}\n         */\n        this._core = carousel;\n\n        /**\n         * All event handlers.\n         * @protected\n         * @type {Object}\n         */\n        this._handlers = {\n            'initialized.owl.carousel': $.proxy(function () {\n                if (this._core.settings.autoHeight) {\n                    this.update();\n                }\n            }, this),\n            'changed.owl.carousel': $.proxy(function (e) {\n                if (this._core.settings.autoHeight && e.property.name == 'position') {\n                    this.update();\n                }\n            }, this),\n            'loaded.owl.lazy': $.proxy(function (e) {\n                if (this._core.settings.autoHeight && e.element.closest('.' + this._core.settings.itemClass)\n                    === this._core.$stage.children().eq(this._core.current())) {\n                    this.update();\n                }\n            }, this)\n        };\n\n        // set default options\n        this._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);\n\n        // register event handlers\n        this._core.$element.on(this._handlers);\n    };\n\n    /**\n     * Default options.\n     * @public\n     */\n    AutoHeight.Defaults = {\n        autoHeight: false,\n        autoHeightClass: 'owl-height'\n    };\n\n    /**\n     * Updates the view.\n     */\n    AutoHeight.prototype.update = function () {\n        this._core.$stage.parent()\n            .height(this._core.$stage.children().eq(this._core.current()).height())\n            .addClass(this._core.settings.autoHeightClass);\n    };\n\n    AutoHeight.prototype.destroy = function () {\n        var handler, property;\n\n        for (handler in this._handlers) {\n            this._core.$element.off(handler, this._handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Video Plugin\n * @version 2.0.0\n * @author Bartosz Wojciechowski\n * @license The MIT License (MIT)\n */\n;\n(function ($, window, document, undefined) {\n\n    /**\n     * Creates the video plugin.\n     * @class The Video Plugin\n     * @param {Owl} carousel - The Owl Carousel\n     */\n    var Video = function (carousel) {\n        /**\n         * Reference to the core.\n         * @protected\n         * @type {Owl}\n         */\n        this._core = carousel;\n\n        /**\n         * Cache all video URLs.\n         * @protected\n         * @type {Object}\n         */\n        this._videos = {};\n\n        /**\n         * Current playing item.\n         * @protected\n         * @type {jQuery}\n         */\n        this._playing = null;\n\n        /**\n         * Whether this is in fullscreen or not.\n         * @protected\n         * @type {Boolean}\n         */\n        this._fullscreen = false;\n\n        /**\n         * All event handlers.\n         * @protected\n         * @type {Object}\n         */\n        this._handlers = {\n            'resize.owl.carousel': $.proxy(function (e) {\n                if (this._core.settings.video && !this.isInFullScreen()) {\n                    e.preventDefault();\n                }\n            }, this),\n            'refresh.owl.carousel changed.owl.carousel': $.proxy(function (e) {\n                if (this._playing) {\n                    this.stop();\n                }\n            }, this),\n            'prepared.owl.carousel': $.proxy(function (e) {\n                var $element = $(e.content).find('.owl-video');\n                if ($element.length) {\n                    $element.css('display', 'none');\n                    this.fetch($element, $(e.content));\n                }\n            }, this)\n        };\n\n        // set default options\n        this._core.options = $.extend({}, Video.Defaults, this._core.options);\n\n        // register event handlers\n        this._core.$element.on(this._handlers);\n\n        this._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function (e) {\n            this.play(e);\n        }, this));\n    };\n\n    /**\n     * Default options.\n     * @public\n     */\n    Video.Defaults = {\n        video: false,\n        videoHeight: false,\n        videoWidth: false\n    };\n\n    /**\n     * Gets the video ID and the type (YouTube/Vimeo only).\n     * @protected\n     * @param {jQuery} target - The target containing the video data.\n     * @param {jQuery} item - The item containing the video.\n     */\n    Video.prototype.fetch = function (target, item) {\n\n        var type = target.attr('data-vimeo-id') ? 'vimeo' : 'youtube',\n            id = target.attr('data-vimeo-id') || target.attr('data-youtube-id'),\n            width = target.attr('data-width') || this._core.settings.videoWidth,\n            height = target.attr('data-height') || this._core.settings.videoHeight,\n            url = target.attr('href');\n\n        if (url) {\n            id = url.match(/(http:|https:|)\\/\\/(player.|www.)?(vimeo\\.com|youtu(be\\.com|\\.be|be\\.googleapis\\.com))\\/(video\\/|embed\\/|watch\\?v=|v\\/)?([A-Za-z0-9._%-]*)(\\&\\S+)?/);\n\n            if (id[3].indexOf('youtu') > -1) {\n                type = 'youtube';\n            } else if (id[3].indexOf('vimeo') > -1) {\n                type = 'vimeo';\n            } else {\n                throw new Error('Video URL not supported.');\n            }\n            id = id[6];\n        } else {\n            throw new Error('Missing video URL.');\n        }\n\n        this._videos[url] = {\n            type: type,\n            id: id,\n            width: width,\n            height: height\n        };\n\n        item.attr('data-video', url);\n\n        this.thumbnail(target, this._videos[url]);\n    };\n\n    /**\n     * Creates video thumbnail.\n     * @protected\n     * @param {jQuery} target - The target containing the video data.\n     * @param {Object} info - The video info object.\n     * @see `fetch`\n     */\n    Video.prototype.thumbnail = function (target, video) {\n\n        var tnLink,\n            icon,\n            path,\n            dimensions = video.width && video.height ? 'style=\"width:' + video.width + 'px;height:' + video.height + 'px;\"' : '',\n            customTn = target.find('img'),\n            srcType = 'src',\n            lazyClass = '',\n            settings = this._core.settings,\n            create = function (path) {\n                icon = '<div class=\"owl-video-play-icon\"></div>';\n\n                if (settings.lazyLoad) {\n                    tnLink = '<div class=\"owl-video-tn ' + lazyClass + '\" ' + srcType + '=\"' + path + '\"></div>';\n                } else {\n                    tnLink = '<div class=\"owl-video-tn\" style=\"opacity:1;background-image:url(' + path + ')\"></div>';\n                }\n                target.after(tnLink);\n                target.after(icon);\n            };\n\n        // wrap video content into owl-video-wrapper div\n        target.wrap('<div class=\"owl-video-wrapper\"' + dimensions + '></div>');\n\n        if (this._core.settings.lazyLoad) {\n            srcType = 'data-src';\n            lazyClass = 'owl-lazy';\n        }\n\n        // custom thumbnail\n        if (customTn.length) {\n            create(customTn.attr(srcType));\n            customTn.remove();\n            return false;\n        }\n\n        if (video.type === 'youtube') {\n            path = \"http://img.youtube.com/vi/\" + video.id + \"/hqdefault.jpg\";\n            create(path);\n        } else if (video.type === 'vimeo') {\n            $.ajax({\n                type: 'GET',\n                url: 'http://vimeo.com/api/v2/video/' + video.id + '.json',\n                jsonp: 'callback',\n                dataType: 'jsonp',\n                success: function (data) {\n                    path = data[0].thumbnail_large;\n                    create(path);\n                }\n            });\n        }\n    };\n\n    /**\n     * Stops the current video.\n     * @public\n     */\n    Video.prototype.stop = function () {\n        this._core.trigger('stop', null, 'video');\n        this._playing.find('.owl-video-frame').remove();\n        this._playing.removeClass('owl-video-playing');\n        this._playing = null;\n    };\n\n    /**\n     * Starts the current video.\n     * @public\n     * @param {Event} ev - The event arguments.\n     */\n    Video.prototype.play = function (ev) {\n        this._core.trigger('play', null, 'video');\n\n        if (this._playing) {\n            this.stop();\n        }\n\n        var target = $(ev.target || ev.srcElement),\n            item = target.closest('.' + this._core.settings.itemClass),\n            video = this._videos[item.attr('data-video')],\n            width = video.width || '100%',\n            height = video.height || this._core.$stage.height(),\n            html, wrap;\n\n        if (video.type === 'youtube') {\n            html = '<iframe width=\"' + width + '\" height=\"' + height + '\" src=\"http://www.youtube.com/embed/'\n            + video.id + '?autoplay=1&v=' + video.id + '\" frameborder=\"0\" allowfullscreen></iframe>';\n        } else if (video.type === 'vimeo') {\n            html = '<iframe src=\"http://player.vimeo.com/video/' + video.id + '?autoplay=1\" width=\"' + width\n            + '\" height=\"' + height\n            + '\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>';\n        }\n\n        item.addClass('owl-video-playing');\n        this._playing = item;\n\n        wrap = $('<div style=\"height:' + height + 'px; width:' + width + 'px\" class=\"owl-video-frame\">'\n        + html + '</div>');\n        target.after(wrap);\n    };\n\n    /**\n     * Checks whether an video is currently in full screen mode or not.\n     * @todo Bad style because looks like a readonly method but changes members.\n     * @protected\n     * @returns {Boolean}\n     */\n    Video.prototype.isInFullScreen = function () {\n\n        // if Vimeo Fullscreen mode\n        var element = document.fullscreenElement || document.mozFullScreenElement\n            || document.webkitFullscreenElement;\n\n        if (element && $(element).parent().hasClass('owl-video-frame')) {\n            this._core.speed(0);\n            this._fullscreen = true;\n        }\n\n        if (element && this._fullscreen && this._playing) {\n            return false;\n        }\n\n        // comming back from fullscreen\n        if (this._fullscreen) {\n            this._fullscreen = false;\n            return false;\n        }\n\n        // check full screen mode and window orientation\n        if (this._playing) {\n            if (this._core.state.orientation !== window.orientation) {\n                this._core.state.orientation = window.orientation;\n                return false;\n            }\n        }\n\n        return true;\n    };\n\n    /**\n     * Destroys the plugin.\n     */\n    Video.prototype.destroy = function () {\n        var handler, property;\n\n        this._core.$element.off('click.owl.video');\n\n        for (handler in this._handlers) {\n            this._core.$element.off(handler, this._handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.Video = Video;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Animate Plugin\n * @version 2.0.0\n * @author Bartosz Wojciechowski\n * @license The MIT License (MIT)\n */\n;\n(function ($, window, document, undefined) {\n\n    /**\n     * Creates the animate plugin.\n     * @class The Navigation Plugin\n     * @param {Owl} scope - The Owl Carousel\n     */\n    var Animate = function (scope) {\n        this.core = scope;\n        this.core.options = $.extend({}, Animate.Defaults, this.core.options);\n        this.swapping = true;\n        this.previous = undefined;\n        this.next = undefined;\n\n        this.handlers = {\n            'change.owl.carousel': $.proxy(function (e) {\n                if (typeof e.property !== 'undefined' && e.property.name == 'position') {\n                    this.previous = this.core.current();\n                    this.next = e.property.value;\n                }\n            }, this),\n            'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function (e) {\n                this.swapping = e.type == 'translated';\n            }, this),\n            'translating.owl.carousel': $.proxy(function (e) {\n                if (this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {\n                    this.swap();\n                }\n            }, this)\n        };\n\n        this.core.$element.on(this.handlers);\n    };\n\n    /**\n     * Default options.\n     * @public\n     */\n    Animate.Defaults = {\n        animateOut: false,\n        animateIn: false\n    };\n\n    /**\n     * Toggles the animation classes whenever an translations starts.\n     * @protected\n     * @returns {Boolean|undefined}\n     */\n    Animate.prototype.swap = function () {\n\n        if (this.core.settings.items !== 1 || !this.core.support3d) {\n            return;\n        }\n\n        this.core.speed(0);\n\n        var left,\n            clear = $.proxy(this.clear, this),\n            previous = this.core.$stage.children().eq(this.previous),\n            next = this.core.$stage.children().eq(this.next),\n            incoming = this.core.settings.animateIn,\n            outgoing = this.core.settings.animateOut;\n\n        if (this.core.current() === this.previous) {\n            return;\n        }\n\n        if (outgoing) {\n            left = this.core.coordinates(this.previous) - this.core.coordinates(this.next);\n            previous.css({'left': left + 'px'})\n                .addClass('animated owl-animated-out')\n                .addClass(outgoing)\n                .one('webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend', clear);\n        }\n\n        if (incoming) {\n            next.addClass('animated owl-animated-in')\n                .addClass(incoming)\n                .one('webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend', clear);\n        }\n    };\n\n    Animate.prototype.clear = function (e) {\n        $(e.target).css({'left': ''})\n            .removeClass('animated owl-animated-out owl-animated-in')\n            .removeClass(this.core.settings.animateIn)\n            .removeClass(this.core.settings.animateOut);\n        this.core.transitionEnd();\n    }\n\n    /**\n     * Destroys the plugin.\n     * @public\n     */\n    Animate.prototype.destroy = function () {\n        var handler, property;\n\n        for (handler in this.handlers) {\n            this.core.$element.off(handler, this.handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.Animate = Animate;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Autoplay Plugin\n * @version 2.0.0\n * @author Bartosz Wojciechowski\n * @license The MIT License (MIT)\n */\n;\n(function ($, window, document, undefined) {\n\n    /**\n     * Creates the autoplay plugin.\n     * @class The Autoplay Plugin\n     * @param {Owl} scope - The Owl Carousel\n     */\n    var Autoplay = function (scope) {\n        this.core = scope;\n        this.core.options = $.extend({}, Autoplay.Defaults, this.core.options);\n\n        this.handlers = {\n            'translated.owl.carousel refreshed.owl.carousel': $.proxy(function () {\n                this.autoplay();\n            }, this),\n            'play.owl.autoplay': $.proxy(function (e, t, s) {\n                this.play(t, s);\n            }, this),\n            'stop.owl.autoplay': $.proxy(function () {\n                this.stop();\n            }, this),\n            'mouseover.owl.autoplay': $.proxy(function () {\n                if (this.core.settings.autoplayHoverPause) {\n                    this.pause();\n                }\n            }, this),\n            'mouseleave.owl.autoplay': $.proxy(function () {\n                if (this.core.settings.autoplayHoverPause) {\n                    this.autoplay();\n                }\n            }, this)\n        };\n\n        this.core.$element.on(this.handlers);\n    };\n\n    /**\n     * Default options.\n     * @public\n     */\n    Autoplay.Defaults = {\n        autoplay: false,\n        autoplayTimeout: 5000,\n        autoplayHoverPause: false,\n        autoplaySpeed: false\n    };\n\n    /**\n     * @protected\n     * @todo Must be documented.\n     */\n    Autoplay.prototype.autoplay = function () {\n        if (this.core.settings.autoplay && !this.core.state.videoPlay) {\n            window.clearInterval(this.interval);\n\n            this.interval = window.setInterval($.proxy(function () {\n                this.play();\n            }, this), this.core.settings.autoplayTimeout);\n        } else {\n            window.clearInterval(this.interval);\n        }\n    };\n\n    /**\n     * Starts the autoplay.\n     * @public\n     * @param {Number} [timeout] - ...\n     * @param {Number} [speed] - ...\n     * @returns {Boolean|undefined} - ...\n     * @todo Must be documented.\n     */\n    Autoplay.prototype.play = function (timeout, speed) {\n        // if tab is inactive - doesnt work in <IE10\n        if (document.hidden === true) {\n            return;\n        }\n\n        if (this.core.state.isTouch || this.core.state.isScrolling\n            || this.core.state.isSwiping || this.core.state.inMotion) {\n            return;\n        }\n\n        if (this.core.settings.autoplay === false) {\n            window.clearInterval(this.interval);\n            return;\n        }\n\n        this.core.next(this.core.settings.autoplaySpeed);\n    };\n\n    /**\n     * Stops the autoplay.\n     * @public\n     */\n    Autoplay.prototype.stop = function () {\n        window.clearInterval(this.interval);\n    };\n\n    /**\n     * Pauses the autoplay.\n     * @public\n     */\n    Autoplay.prototype.pause = function () {\n        window.clearInterval(this.interval);\n    };\n\n    /**\n     * Destroys the plugin.\n     */\n    Autoplay.prototype.destroy = function () {\n        var handler, property;\n\n        window.clearInterval(this.interval);\n\n        for (handler in this.handlers) {\n            this.core.$element.off(handler, this.handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Navigation Plugin\n * @version 2.0.0\n * @author Artus Kolanowski\n * @license The MIT License (MIT)\n */\n;\n(function ($, window, document, undefined) {\n    'use strict';\n\n    /**\n     * Creates the navigation plugin.\n     * @class The Navigation Plugin\n     * @param {Owl} carousel - The Owl Carousel.\n     */\n    var Navigation = function (carousel) {\n        /**\n         * Reference to the core.\n         * @protected\n         * @type {Owl}\n         */\n        this._core = carousel;\n\n        /**\n         * Indicates whether the plugin is initialized or not.\n         * @protected\n         * @type {Boolean}\n         */\n        this._initialized = false;\n\n        /**\n         * The current paging indexes.\n         * @protected\n         * @type {Array}\n         */\n        this._pages = [];\n\n        /**\n         * All DOM elements of the user interface.\n         * @protected\n         * @type {Object}\n         */\n        this._controls = {};\n\n        /**\n         * Markup for an indicator.\n         * @protected\n         * @type {Array.<String>}\n         */\n        this._templates = [];\n\n        /**\n         * The carousel element.\n         * @type {jQuery}\n         */\n        this.$element = this._core.$element;\n\n        /**\n         * Overridden methods of the carousel.\n         * @protected\n         * @type {Object}\n         */\n        this._overrides = {\n            next: this._core.next,\n            prev: this._core.prev,\n            to: this._core.to\n        };\n\n        /**\n         * All event handlers.\n         * @protected\n         * @type {Object}\n         */\n        this._handlers = {\n            'prepared.owl.carousel': $.proxy(function (e) {\n                if (this._core.settings.dotsData) {\n                    this._templates.push($(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot'));\n                }\n            }, this),\n            'add.owl.carousel': $.proxy(function (e) {\n                if (this._core.settings.dotsData) {\n                    this._templates.splice(e.position, 0, $(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot'));\n                }\n            }, this),\n            'remove.owl.carousel prepared.owl.carousel': $.proxy(function (e) {\n                if (this._core.settings.dotsData) {\n                    this._templates.splice(e.position, 1);\n                }\n            }, this),\n            'change.owl.carousel': $.proxy(function (e) {\n                if(typeof e.property !== 'undefined' && e.property.name == 'position') {\n                    if (!this._core.state.revert && !this._core.settings.loop && this._core.settings.navRewind) {\n                        var current = this._core.current(),\n                            maximum = this._core.maximum(),\n                            minimum = this._core.minimum();\n                        e.data = e.property.value > maximum\n                            ? current >= maximum ? minimum : maximum\n                            : e.property.value < minimum ? maximum : e.property.value;\n                    }\n                }\n            }, this),\n            'changed.owl.carousel': $.proxy(function (e) {\n                if (e.property.name == 'position') {\n                    this.draw();\n                }\n            }, this),\n            'refreshed.owl.carousel': $.proxy(function () {\n                if (!this._initialized) {\n                    this.initialize();\n                    this._initialized = true;\n                }\n                this._core.trigger('refresh', null, 'navigation');\n                this.update();\n                this.draw();\n                this._core.trigger('refreshed', null, 'navigation');\n            }, this)\n        };\n\n        // set default options\n        this._core.options = $.extend({}, Navigation.Defaults, this._core.options);\n\n        // register event handlers\n        this.$element.on(this._handlers);\n    }\n\n    /**\n     * Default options.\n     * @public\n     * @todo Rename `slideBy` to `navBy`\n     */\n    Navigation.Defaults = {\n        nav: false,\n        navRewind: true,\n        navText: ['prev', 'next'],\n        navSpeed: false,\n        navElement: 'div',\n        navContainer: false,\n        navContainerClass: 'owl-nav',\n        navClass: ['owl-prev', 'owl-next'],\n        slideBy: 1,\n        dotClass: 'owl-dot',\n        dotsClass: 'owl-dots',\n        dots: true,\n        dotsEach: false,\n        dotData: false,\n        dotsSpeed: false,\n        dotsContainer: false,\n        controlsClass: 'owl-controls'\n    }\n\n    /**\n     * Initializes the layout of the plugin and extends the carousel.\n     * @protected\n     */\n    Navigation.prototype.initialize = function () {\n        var $container, override,\n            options = this._core.settings;\n\n        // create the indicator template\n        if (!options.dotsData) {\n            this._templates = [$('<div>')\n                .addClass(options.dotClass)\n                .append($('<span>'))\n                .prop('outerHTML')];\n        }\n\n        // create controls container if needed\n        if (!options.navContainer || !options.dotsContainer) {\n            this._controls.$container = $('<div>')\n                .addClass(options.controlsClass)\n                .appendTo(this.$element);\n        }\n\n        // create DOM structure for absolute navigation\n        this._controls.$indicators = options.dotsContainer ? $(options.dotsContainer)\n            : $('<div>').hide().addClass(options.dotsClass).appendTo(this._controls.$container);\n\n        this._controls.$indicators.on('click', 'div', $.proxy(function (e) {\n            var index = $(e.target).parent().is(this._controls.$indicators)\n                ? $(e.target).index() : $(e.target).parent().index();\n\n            e.preventDefault();\n\n            this.to(index, options.dotsSpeed);\n        }, this));\n\n        // create DOM structure for relative navigation\n        $container = options.navContainer ? $(options.navContainer)\n            : $('<div>').addClass(options.navContainerClass).prependTo(this._controls.$container);\n\n        this._controls.$next = $('<' + options.navElement + '>');\n        this._controls.$previous = this._controls.$next.clone();\n\n        this._controls.$previous\n            .addClass(options.navClass[0])\n            .html(options.navText[0])\n            .hide()\n            .prependTo($container)\n            .on('click', $.proxy(function (e) {\n                this.prev(options.navSpeed);\n            }, this));\n        this._controls.$next\n            .addClass(options.navClass[1])\n            .html(options.navText[1])\n            .hide()\n            .appendTo($container)\n            .on('click', $.proxy(function (e) {\n                this.next(options.navSpeed);\n            }, this));\n\n        // override public methods of the carousel\n        for (override in this._overrides) {\n            this._core[override] = $.proxy(this[override], this);\n        }\n    }\n\n    /**\n     * Destroys the plugin.\n     * @protected\n     */\n    Navigation.prototype.destroy = function () {\n        var handler, control, property, override;\n\n        for (handler in this._handlers) {\n            this.$element.off(handler, this._handlers[handler]);\n        }\n        for (control in this._controls) {\n            this._controls[control].remove();\n        }\n        for (override in this.overides) {\n            this._core[override] = this._overrides[override];\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    }\n\n    /**\n     * Updates the internal state.\n     * @protected\n     */\n    Navigation.prototype.update = function () {\n        var i, j, k,\n            options = this._core.settings,\n            lower = this._core.clones().length / 2,\n            upper = lower + this._core.items().length,\n            size = options.center || options.autoWidth || options.dotData\n                ? 1 : options.dotsEach || options.items;\n\n        if (options.slideBy !== 'page') {\n            options.slideBy = Math.min(options.slideBy, options.items);\n        }\n\n        if (options.dots || options.slideBy == 'page') {\n            this._pages = [];\n\n            for (i = lower, j = 0, k = 0; i < upper; i++) {\n                if (j >= size || j === 0) {\n                    this._pages.push({\n                        start: i - lower,\n                        end: i - lower + size - 1\n                    });\n                    j = 0, ++k;\n                }\n                j += this._core.mergers(this._core.relative(i));\n            }\n        }\n    }\n\n    /**\n     * Draws the user interface.\n     * @todo The option `dotData` wont work.\n     * @protected\n     */\n    Navigation.prototype.draw = function () {\n        var difference, i, html = '',\n            options = this._core.settings,\n            $items = this._core.$stage.children(),\n            index = this._core.relative(this._core.current());\n\n        if (options.nav && !options.loop && !options.navRewind) {\n            this._controls.$previous.toggleClass('disabled', index <= 0);\n            this._controls.$next.toggleClass('disabled', index >= this._core.maximum());\n        }\n\n        this._controls.$previous.toggle(options.nav);\n        this._controls.$next.toggle(options.nav);\n\n        if (options.dots) {\n            difference = this._pages.length - this._controls.$indicators.children().length;\n\n            if (options.dotData && difference !== 0) {\n                for (i = 0; i < this._controls.$indicators.children().length; i++) {\n                    html += this._templates[this._core.relative(i)];\n                }\n                this._controls.$indicators.html(html);\n            } else if (difference > 0) {\n                html = new Array(difference + 1).join(this._templates[0]);\n                this._controls.$indicators.append(html);\n            } else if (difference < 0) {\n                this._controls.$indicators.children().slice(difference).remove();\n            }\n\n            this._controls.$indicators.find('.active').removeClass('active');\n            this._controls.$indicators.children().eq($.inArray(this.current(), this._pages)).addClass('active');\n        }\n\n        this._controls.$indicators.toggle(options.dots);\n    }\n\n    /**\n     * Extends event data.\n     * @protected\n     * @param {Event} event - The event object which gets thrown.\n     */\n    Navigation.prototype.onTrigger = function (event) {\n        var settings = this._core.settings;\n\n        event.page = {\n            index: $.inArray(this.current(), this._pages),\n            count: this._pages.length,\n            size: settings && (settings.center || settings.autoWidth || settings.dotData\n                ? 1 : settings.dotsEach || settings.items)\n        };\n    }\n\n    /**\n     * Gets the current page position of the carousel.\n     * @protected\n     * @returns {Number}\n     */\n    Navigation.prototype.current = function () {\n        var index = this._core.relative(this._core.current());\n        return $.grep(this._pages, function (o) {\n            return o.start <= index && o.end >= index;\n        }).pop();\n    }\n\n    /**\n     * Gets the current succesor/predecessor position.\n     * @protected\n     * @returns {Number}\n     */\n    Navigation.prototype.getPosition = function (successor) {\n        var position, length,\n            options = this._core.settings;\n\n        if (options.slideBy == 'page') {\n            position = $.inArray(this.current(), this._pages);\n            length = this._pages.length;\n            successor ? ++position : --position;\n            position = this._pages[((position % length) + length) % length].start;\n        } else {\n            position = this._core.relative(this._core.current());\n            length = this._core.items().length;\n            successor ? position += options.slideBy : position -= options.slideBy;\n        }\n        return position;\n    }\n\n    /**\n     * Slides to the next item or page.\n     * @public\n     * @param {Number} [speed=false] - The time in milliseconds for the transition.\n     */\n    Navigation.prototype.next = function (speed) {\n        $.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);\n    }\n\n    /**\n     * Slides to the previous item or page.\n     * @public\n     * @param {Number} [speed=false] - The time in milliseconds for the transition.\n     */\n    Navigation.prototype.prev = function (speed) {\n        $.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);\n    }\n\n    /**\n     * Slides to the specified item or page.\n     * @public\n     * @param {Number} position - The position of the item or page.\n     * @param {Number} [speed] - The time in milliseconds for the transition.\n     * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.\n     */\n    Navigation.prototype.to = function (position, speed, standard) {\n        var length;\n\n        if (!standard) {\n            length = this._pages.length;\n            $.proxy(this._overrides.to, this._core)(this._pages[((position % length) + length) % length].start, speed);\n        } else {\n            $.proxy(this._overrides.to, this._core)(position, speed);\n        }\n    }\n\n    $.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Hash Plugin\n * @version 2.0.0\n * @author Artus Kolanowski\n * @license The MIT License (MIT)\n */\n;\n(function ($, window, document, undefined) {\n    'use strict';\n\n    /**\n     * Creates the hash plugin.\n     * @class The Hash Plugin\n     * @param {Owl} carousel - The Owl Carousel\n     */\n    var Hash = function (carousel) {\n        /**\n         * Reference to the core.\n         * @protected\n         * @type {Owl}\n         */\n        this._core = carousel;\n\n        /**\n         * Hash table for the hashes.\n         * @protected\n         * @type {Object}\n         */\n        this._hashes = {};\n\n        /**\n         * The carousel element.\n         * @type {jQuery}\n         */\n        this.$element = this._core.$element;\n\n        /**\n         * All event handlers.\n         * @protected\n         * @type {Object}\n         */\n        this._handlers = {\n            'initialized.owl.carousel': $.proxy(function () {\n                if (this._core.settings.startPosition == 'URLHash') {\n                    $(window).trigger('hashchange.owl.navigation');\n                }\n            }, this),\n            'prepared.owl.carousel': $.proxy(function (e) {\n                var hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');\n                this._hashes[hash] = e.content;\n            }, this)\n        };\n\n        // set default options\n        this._core.options = $.extend({}, Hash.Defaults, this._core.options);\n\n        // register the event handlers\n        this.$element.on(this._handlers);\n\n        // register event listener for hash navigation\n        $(window).on('hashchange.owl.navigation', $.proxy(function () {\n            var hash = window.location.hash.substring(1),\n                items = this._core.$stage.children(),\n                position = this._hashes[hash] && items.index(this._hashes[hash]) || 0;\n\n            if (!hash) {\n                return false;\n            }\n\n            this._core.to(position, false, true);\n        }, this));\n    }\n\n    /**\n     * Default options.\n     * @public\n     */\n    Hash.Defaults = {\n        URLhashListener: false\n    }\n\n    /**\n     * Destroys the plugin.\n     * @public\n     */\n    Hash.prototype.destroy = function () {\n        var handler, property;\n\n        $(window).off('hashchange.owl.navigation');\n\n        for (handler in this._handlers) {\n            this._core.$element.off(handler, this._handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    }\n\n    $.fn.owlCarousel.Constructor.Plugins.Hash = Hash;\n\n})(window.Zepto || window.jQuery, window, document);\n });","Sm_ShopBy/js/product/list/toolbar.js":"/**\n *\n * SM Shop By - Version 2.0.0\n * Copyright (c) 2017 YouTech Company. All Rights Reserved.\n * @license - Copyrighted Commercial Software\n * Author: YouTech Company\n * Websites: http://www.magentech.com\n */\n\ndefine([\n    \"jquery\",\n    \"jquery/ui\",\n    \"Magento_Theme/js/view/messages\",\n    \"ko\",\n    \"Magento_Catalog/js/product/list/toolbar\",\n    \"jquery/ui-modules/widgets/slider\"\n], function ($, ui, messageComponent, ko) {\n\n    $.widget('mage.productListToolbarForm', $.mage.productListToolbarForm, {\n        options: {\n            modeControl: '[data-role=\"mode-switcher\"]',\n            directionControl: '[data-role=\"direction-switcher\"]',\n            orderControl: '[data-role=\"sorter\"]',\n            limitControl: '[data-role=\"limiter\"]',\n            pagerControl: '.pages-items a',\n            mode: 'product_list_mode',\n            direction: 'product_list_dir',\n            order: 'product_list_order',\n            limit: 'product_list_limit',\n            pager: 'p',\n            modeDefault: 'grid',\n            directionDefault: 'asc',\n            orderDefault: 'position',\n            limitDefault: '9',\n            pagerDefault: '1',\n            priceSliderWrap: '.price-slider-wrap',\n            priceMinMax: 'input[name=\"price_minimum\"], input[name=\"price_maximum\"]',\n            price: 'price',\n            loadingMark: '.loading-mask-shopby',\n            priceDefault: '',\n            productsToolbarControl: '.toolbar.toolbar-products',\n            productsListBlock: '.products.wrapper',\n            layeredNavigationFilterBlock: '.block.filter',\n            filterItemControl: '.block.filter .item a, .block.filter .filter-clear,.block.filter .swatch-option-link-layered',\n            url: ''\n        },\n\n        _create: function () {\n            this._super();\n            this._bind($(this.options.pagerControl), this.options.pager, this.options.pagerDefault);\n            this._bind($(this.options.priceMinMax), this.options.price, this.options.priceDefault);\n            $(this.options.filterItemControl)\n                .off('click.' + this.namespace + 'productListToolbarForm')\n                .on('click.' + this.namespace + 'productListToolbarForm', {}, $.proxy(this.applyFilterToProductsList, this))\n            ;\n        },\n\n        _bind: function (element, paramName, defaultValue) {\n            if (element.is(\"select\")) {\n                element\n                    .off('change.' + this.namespace + 'productListToolbarForm')\n                    .on('change.' + this.namespace + 'productListToolbarForm', {\n                        paramName: paramName,\n                        default: defaultValue\n                    }, $.proxy(this._processSelect, this));\n            } else if (element.is(\"input\")) {\n                element\n                    .off('change.' + this.namespace + 'productListToolbarForm')\n                    .on('change.' + this.namespace + 'productListToolbarForm', {\n                        paramName: paramName,\n                        default: defaultValue\n                    }, $.proxy(this._processSlider, this));\n                this._startSlider();\n            } else {\n                element\n                    .off('click.' + this.namespace + 'productListToolbarForm')\n                    .on('click.' + this.namespace + 'productListToolbarForm', {\n                        paramName: paramName,\n                        default: defaultValue\n                    }, $.proxy(this._processLink, this));\n            }\n        },\n\n        _processSlider: function (event) {\n            event.preventDefault();\n            var that = this;\n            var _slider_wrap = $(this.options.priceSliderWrap),\n                _slider = $('#price-slider', _slider_wrap),\n                _data_rate = Number(_slider.attr('data-rate')),\n                _min_standard = Number(_slider.attr('data-min-standard')),\n                _max_standard = Number(_slider.attr('data-max-standard')),\n                _min_price = $('#price_minimum', _slider_wrap),\n                _min_price_value = Number(_min_price.val()),\n                _max_price = $('#price_maximum', _slider_wrap),\n                _max_price_value = Number(_max_price.val());\n            _min_price_value = (_min_price_value < _min_standard || !$.isNumeric(_min_price_value)) ? _min_standard : _min_price_value;\n            _max_price_value = (_max_price_value > _max_standard || !$.isNumeric(_max_price_value)) ? _max_standard : _max_price_value;\n            _min_price.val(_min_price_value);\n            _max_price.val(_max_price_value);\n            var _max_price_url = Number(_max_price.val() / _data_rate) + 0.01;\n            this.changeUrl(\n                event.data.paramName,\n                Number(_min_price.val() / _data_rate).toFixed(2) + '-' + _max_price_url.toFixed(2),\n                event.data.default\n            );\n        },\n        _processLink: function (event) {\n            event.preventDefault();\n            var _parent = $(event.currentTarget).parents('.sidebar-main , .toolbar-products');\n            var _data = $(event.currentTarget).data('value');\n            if (_parent.length) {\n                if (typeof _data == 'undefined') {\n                    var _tmp, urlPaths = $(event.currentTarget).attr('href').split('?'),\n                        //baseUrl = urlPaths[0],\n                        flag,\n                        urlParams = urlPaths[1] ? urlPaths[1].split('&') : [];\n                    if (urlParams.length) {\n                        for (var i = 0; i < urlParams.length; i++) {\n                            if (urlParams[i].search('p=') !== -1) {\n                                flag = 1;\n\n                            } else {\n                                flag = 0;\n                            }\n                        }\n\n                        if (flag) {\n                            var link = $(event.currentTarget);\n                            var urlParts = link.attr('href').split('?');\n                            this.processAjaxCall(urlParts[0], urlParts[1]);\n\t\t\t\t\t\t\ti--;\n                            _tmp = urlParams[i].split('=');\n                            this.changeUrl(\n                                event.data.paramName,\n                                _tmp[1],\n                                event.data.default\n                            );\n                        } else {\n                            var link = $(event.currentTarget);\n                            var urlParts = link.attr('href').split('?');\n                            this.processAjaxCall(urlParts[0], urlParts[1]);\n                        }\n                    } else {\n                        var link = $(event.currentTarget);\n                        var urlParts = link.attr('href').split('?');\n                        this.processAjaxCall(urlParts[0], urlParts[1]);\n                        //event.preventDefault();\n                    }\n                } else {\n                    this.changeUrl(\n                        event.data.paramName,\n                        $(event.currentTarget).data('value'),\n                        event.data.default\n                    );\n                }\n            } else {\n                this.changeUrlOriginal(\n                    event.data.paramName,\n                    $(event.currentTarget).data('value'),\n                    event.data.default\n                );\n            }\n        },\n        _processSelect: function (event) {\n            var _parent = $(event.currentTarget).parents('.sidebar-main, .toolbar-products');\n            if (_parent.length) {\n                this.changeUrl(\n                    event.data.paramName,\n                    event.currentTarget.options[event.currentTarget.selectedIndex].value,\n                    event.data.default\n                );\n            } else {\n                this.changeUrlOriginal(\n                    event.data.paramName,\n                    event.currentTarget.options[event.currentTarget.selectedIndex].value,\n                    event.data.default\n                );\n            }\n\n        },\n        changeUrlOriginal: function (paramName, paramValue, defaultValue) {\n            var decode = window.decodeURIComponent,\n                urlPaths = this.options.url.split('?'),\n                baseUrl = urlPaths[0],\n                urlParams = urlPaths[1] ? urlPaths[1].split('&') : [],\n                paramData = {},\n                parameters, i;\n\n            for (i = 0; i < urlParams.length; i++) {\n                parameters = urlParams[i].split('=');\n                paramData[decode(parameters[0])] = parameters[1] !== undefined ?\n                    decode(parameters[1].replace(/\\+/g, '%20')) :\n                    '';\n            }\n            paramData[paramName] = paramValue;\n\n            if (paramValue == defaultValue) { //eslint-disable-line eqeqeq\n                delete paramData[paramName];\n            }\n            paramData = $.param(paramData);\n\n            location.href = baseUrl + (paramData.length ? '?' + paramData : '');\n        },\n        _startSlider: function () {\n            var that = this;\n            var _slider_wrap = $(this.options.priceSliderWrap),\n                _slider = $('#price-slider', _slider_wrap),\n                _data_rate = Number(_slider.attr('data-rate')),\n                _min_standard = Number(_slider.attr('data-min-standard')),\n                _max_standard = Number(_slider.attr('data-max-standard')),\n                _min_price = $('#price_minimum', _slider_wrap),\n                _min_price_value = Number(_min_price.val()),\n                _max_price = $('#price_maximum', _slider_wrap),\n                _max_price_value = Number(_max_price.val());\n            _slider.slider({\n                range: true,\n                min: _min_standard,\n                max: _max_standard,\n                values: [_min_price_value, _max_price_value],\n                slide: function (event, ui) {\n                    _min_price.val(ui.values[0]);\n                    _max_price.val(ui.values[1]);\n                },\n                stop: function (event, ui) {\n                    var _max_price_url = Number(ui.values[1] / _data_rate) + 0.01;\n                    that.changeUrl(\n                        'price',\n                        Number(_min_price.val() / _data_rate).toFixed(2) + '-' + _max_price_url.toFixed(2),\n                        null\n                    );\n                }\n            });\n        },\n        applyFilterToProductsList: function (eve) {\n            var link = $(eve.currentTarget);\n            var urlParts = link.attr('href').split('?');\n            this.processAjaxCall(urlParts[0], urlParts[1]);\n            eve.preventDefault();\n        },\n        updateUrl: function (url, paramData) {\n            if (!url) {\n                return;\n            }\n            if (paramData && paramData.length > 0) {\n                url += '?' + paramData;\n            }\n            url = (url.search('ajax=1&') !== -1) ? url.replace('ajax=1&', '') : url;\n            if (typeof history.replaceState === 'function') {\n                history.replaceState(null, null, url);\n            }\n        },\n\n        getParams: function (urlParams, paramName, paramValue, defaultValue) {\n            var paramData = {},\n                parameters;\n\n            for (var i = 0; i < urlParams.length; i++) {\n                parameters = urlParams[i].split('=');\n                if (parameters[1] !== undefined) {\n                    paramData[parameters[0]] = parameters[1];\n                } else {\n                    paramData[parameters[0]] = '';\n                }\n            }\n\n            paramData[paramName] = paramValue;\n            if (paramValue == defaultValue) {\n                delete paramData[paramName];\n            }\n            return window.decodeURIComponent($.param(paramData).replace(/\\+/g, '%20'));\n        },\n\n        _updateContent: function (content) {\n            $(this.options.productsToolbarControl).remove();\n            if (content.products_list) {\n                if ($(content.products_list).hasClass('search results') && $('.search.results').length) {\n                    $('.search.results').replaceWith(content.products_list);\n                } else {\n                    $(this.options.productsListBlock).replaceWith(content.products_list);\n                }\n            }\n\n            if (content.filters) {\n                $(this.options.layeredNavigationFilterBlock).replaceWith(content.filters);\n            }\n            if ($(this.options.productsListBlock).length) {\n                this._create();\n                $('body').trigger('contentUpdated');\n            }\n        },\n\n        updateContent: function (content) {\n            $('html, body').animate(\n                {\n                    scrollTop: $(this.options.productsToolbarControl + \":first\").offset().top\n                },\n                100,\n                'swing',\n                this._updateContent(content)\n            );\n        },\n\n        changeUrl: function (paramName, paramValue, defaultValue) {\n            var urlPaths = this.options.url.split('?'),\n                baseUrl = urlPaths[0],\n                urlParams = urlPaths[1] ? urlPaths[1].split('&') : [],\n                paramData = this.getParams(urlParams, paramName, paramValue, defaultValue);\n            this.processAjaxCall(baseUrl, paramData);\n        },\n\n        processAjaxCall: function (baseUrl, paramData) {\n            var that = this;\n            var self = this;\n            $.ajax({\n                url: baseUrl,\n                data: (paramData && paramData.length > 0 ? paramData + '&ajax=1' : 'ajax=1'),\n                type: 'get',\n                dataType: 'json',\n                cache: true,\n                beforeSend: function () {\n                    $(document).trigger('tap');\n                    $(that.options.loadingMark).show();\n                },\n                showLoader: false\n            }).done(function (response) {\n                if (response.success) {\n                    self.updateUrl(baseUrl, paramData);\n                    self.updateContent(response.html);\n                    self.setMessage({\n                        type: 'success',\n                        text: $.mage.__('Sections have been updated')\n                    });\n                } else {\n                    var msg = response.error_message;\n                    if (msg) {\n                        self.setMessage({\n                            type: 'error',\n                            text: msg\n                        });\n                    }\n                }\n                $(that.options.loadingMark).hide();\n                $(document).trigger(\"afterAjaxProductsLoaded\");\n                $(document).trigger(\"afterAjaxLazyLoad\");\n            }).fail(function (error) {\n                self.setMessage({\n                    type: 'error',\n                    text: $.mage.__('Sorry, something went wrong. Please try again later.')\n                });\n                $(that.options.loadingMark).hide();\n            });\n        },\n\n        setMessage: function (obj) {\n            var messages = ko.observableArray([obj]);\n            messageComponent().messages({\n                messages: messages\n            });\n        }\n    });\n\n    return $.mage.productListToolbarForm;\n});\n","Sm_SizeChart/js/sizechart.js":"define([\n        'jquery',\n        'Magento_Ui/js/modal/modal',\n        \"domReady!\"\n    ],\n    function ($, modal) {\n        var options = {\n            type: 'popup',\n            responsive: true,\n            innerScroll: true,\n            modalClass: 'sm-sizechart',\n            buttons: []\n        };\n\n        if ($('#modal-sizechart').length) {\n            var popup = modal(options, $('#modal-sizechart'));\n            var appendButon = setInterval(setButton, 1000);\n            var sizeCode = \".\" + $(\"#sm-sizechart-container\").data('size-code');\n        }\n\n        function setButton() {\n            $(\".product-info-main .product-options-wrapper \" + sizeCode).addClass(\"has-sizechart\").append($(\"#button-sizechart-append\"));\n\n            if ($(\".product-info-main .product-options-wrapper \" + sizeCode + \" #button-sizechart-append\").length) {\n                clearInterval(appendButon);\n            }\n        }\n\n        $(document).on('click', '#sizechart-btn', function () {\n            $(\"#modal-sizechart\").modal(\"openModal\");\n        });\n    });","vimeo/player.min.js":"/*! @vimeo/player v2.16.4 | (c) 2022 Vimeo | MIT License | https://github.com/vimeo/player.js */\n!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):((e=\"undefined\"!=typeof globalThis?globalThis:e||self).Vimeo=e.Vimeo||{},e.Vimeo.Player=t())}(this,function(){\"use strict\";function r(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var e=\"undefined\"!=typeof global&&\"[object global]\"==={}.toString.call(global);function i(e,t){return 0===e.indexOf(t.toLowerCase())?e:\"\".concat(t.toLowerCase()).concat(e.substr(0,1).toUpperCase()).concat(e.substr(1))}function l(e){return/^(https?:)?\\/\\/((player|www)\\.)?vimeo\\.com(?=$|\\/)/.test(e)}function u(e){var t=0<arguments.length&&void 0!==e?e:{},n=t.id,e=t.url,t=n||e;if(!t)throw new Error(\"An id or url must be passed, either in an options object or as a data-vimeo-id or data-vimeo-url attribute.\");if(e=t,!isNaN(parseFloat(e))&&isFinite(e)&&Math.floor(e)==e)return\"https://vimeo.com/\".concat(t);if(l(t))return t.replace(\"http:\",\"https:\");if(n)throw new TypeError(\"\u201c\".concat(n,\"\u201d is not a valid video id.\"));throw new TypeError(\"\u201c\".concat(t,\"\u201d is not a vimeo.com url.\"))}var t=void 0!==Array.prototype.indexOf,Player=\"undefined\"!=typeof window&&void 0!==window.postMessage;if(!(e||t&&Player))throw new Error(\"Sorry, the Vimeo Player API is not available in this browser.\");var n,o,a=\"undefined\"!=typeof globalThis?globalThis:\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:{};function c(){if(void 0===this)throw new TypeError(\"Constructor WeakMap requires 'new'\");if(o(this,\"_id\",\"_WeakMap_\"+f()+\".\"+f()),0<arguments.length)throw new TypeError(\"WeakMap iterable is not supported\")}function s(e,t){if(!d(e)||!n.call(e,\"_id\"))throw new TypeError(t+\" method called on incompatible receiver \"+typeof e)}function f(){return Math.random().toString().substring(2)}function d(e){return Object(e)===e}(Player=\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:a).WeakMap||(n=Object.prototype.hasOwnProperty,Player.WeakMap=((o=function(e,t,n){Object.defineProperty?Object.defineProperty(e,t,{configurable:!0,writable:!0,value:n}):e[t]=n})(c.prototype,\"delete\",function(e){if(s(this,\"delete\"),!d(e))return!1;var t=e[this._id];return!(!t||t[0]!==e)&&(delete e[this._id],!0)}),o(c.prototype,\"get\",function(e){if(s(this,\"get\"),d(e)){var t=e[this._id];return t&&t[0]===e?t[1]:void 0}}),o(c.prototype,\"has\",function(e){if(s(this,\"has\"),!d(e))return!1;var t=e[this._id];return!(!t||t[0]!==e)}),o(c.prototype,\"set\",function(e,t){if(s(this,\"set\"),!d(e))throw new TypeError(\"Invalid value used as weak map key\");var n=e[this._id];return n&&n[0]===e?n[1]=t:o(e,this._id,[e,t]),this}),o(c,\"_polyfill\",!0),c));var h,m=(function(e){var t,n,r;r=function(){var t,n,r,o,i,e=Object.prototype.toString,a=\"undefined\"!=typeof setImmediate?function(e){return setImmediate(e)}:setTimeout;try{Object.defineProperty({},\"x\",{}),t=function(e,t,n,r){return Object.defineProperty(e,t,{value:n,writable:!0,configurable:!1!==r})}}catch(e){t=function(e,t,n){return e[t]=n,e}}function u(e,t){this.fn=e,this.self=t,this.next=void 0}function l(e,t){y.add(e,t),n=n||a(y.drain)}function c(e){var t,n=typeof e;return\"function\"==typeof(t=null!=e&&(\"object\"==n||\"function\"==n)?e.then:t)&&t}function s(){for(var e=0;e<this.chain.length;e++)!function(e,t,n){var r,o;try{!1===t?n.reject(e.msg):(r=!0===t?e.msg:t.call(void 0,e.msg))===n.promise?n.reject(TypeError(\"Promise-chain cycle\")):(o=c(r))?o.call(r,n.resolve,n.reject):n.resolve(r)}catch(e){n.reject(e)}}(this,1===this.state?this.chain[e].success:this.chain[e].failure,this.chain[e]);this.chain.length=0}function f(e){var n,r=this;if(!r.triggered){r.triggered=!0,r.def&&(r=r.def);try{(n=c(e))?l(function(){var t=new m(r);try{n.call(e,function(){f.apply(t,arguments)},function(){d.apply(t,arguments)})}catch(e){d.call(t,e)}}):(r.msg=e,r.state=1,0<r.chain.length&&l(s,r))}catch(e){d.call(new m(r),e)}}}function d(e){var t=this;t.triggered||(t.triggered=!0,(t=t.def?t.def:t).msg=e,t.state=2,0<t.chain.length&&l(s,t))}function h(e,n,r,o){for(var t=0;t<n.length;t++)!function(t){e.resolve(n[t]).then(function(e){r(t,e)},o)}(t)}function m(e){this.def=e,this.triggered=!1}function v(e){this.promise=e,this.state=0,this.triggered=!1,this.chain=[],this.msg=void 0}function p(e){if(\"function\"!=typeof e)throw TypeError(\"Not a function\");if(0!==this.__NPO__)throw TypeError(\"Not a promise\");this.__NPO__=1;var r=new v(this);this.then=function(e,t){var n={success:\"function\"!=typeof e||e,failure:\"function\"==typeof t&&t};return n.promise=new this.constructor(function(e,t){if(\"function\"!=typeof e||\"function\"!=typeof t)throw TypeError(\"Not a function\");n.resolve=e,n.reject=t}),r.chain.push(n),0!==r.state&&l(s,r),n.promise},this.catch=function(e){return this.then(void 0,e)};try{e.call(void 0,function(e){f.call(r,e)},function(e){d.call(r,e)})}catch(e){d.call(r,e)}}var y={add:function(e,t){i=new u(e,t),o?o.next=i:r=i,o=i,i=void 0},drain:function(){var e=r;for(r=o=n=void 0;e;)e.fn.call(e.self),e=e.next}},g=t({},\"constructor\",p,!1);return t(p.prototype=g,\"__NPO__\",0,!1),t(p,\"resolve\",function(n){return n&&\"object\"==typeof n&&1===n.__NPO__?n:new this(function(e,t){if(\"function\"!=typeof e||\"function\"!=typeof t)throw TypeError(\"Not a function\");e(n)})}),t(p,\"reject\",function(n){return new this(function(e,t){if(\"function\"!=typeof e||\"function\"!=typeof t)throw TypeError(\"Not a function\");t(n)})}),t(p,\"all\",function(t){var a=this;return\"[object Array]\"!=e.call(t)?a.reject(TypeError(\"Not an array\")):0===t.length?a.resolve([]):new a(function(n,e){if(\"function\"!=typeof n||\"function\"!=typeof e)throw TypeError(\"Not a function\");var r=t.length,o=Array(r),i=0;h(a,t,function(e,t){o[e]=t,++i===r&&n(o)},e)})}),t(p,\"race\",function(t){var r=this;return\"[object Array]\"!=e.call(t)?r.reject(TypeError(\"Not an array\")):new r(function(n,e){if(\"function\"!=typeof n||\"function\"!=typeof e)throw TypeError(\"Not a function\");h(r,t,function(e,t){n(t)},e)})}),p},(n=a)[t=\"Promise\"]=n[t]||r(),e.exports&&(e.exports=n[t])}(h={exports:{}}),h.exports),v=new WeakMap;function p(e,t,n){var r=v.get(e.element)||{};t in r||(r[t]=[]),r[t].push(n),v.set(e.element,r)}function y(e,t){return(v.get(e.element)||{})[t]||[]}function g(e,t,n){var r=v.get(e.element)||{};if(!r[t])return!0;if(!n)return r[t]=[],v.set(e.element,r),!0;n=r[t].indexOf(n);return-1!==n&&r[t].splice(n,1),v.set(e.element,r),r[t]&&0===r[t].length}var w=[\"autopause\",\"autoplay\",\"background\",\"byline\",\"color\",\"controls\",\"dnt\",\"height\",\"id\",\"interactive_params\",\"keyboard\",\"loop\",\"maxheight\",\"maxwidth\",\"muted\",\"playsinline\",\"portrait\",\"responsive\",\"speed\",\"texttrack\",\"title\",\"transparent\",\"url\",\"width\"];function b(r,e){return w.reduce(function(e,t){var n=r.getAttribute(\"data-vimeo-\".concat(t));return!n&&\"\"!==n||(e[t]=\"\"===n?1:n),e},1<arguments.length&&void 0!==e?e:{})}function k(e,t){var n=e.html;if(!t)throw new TypeError(\"An element must be provided\");if(null!==t.getAttribute(\"data-vimeo-initialized\"))return t.querySelector(\"iframe\");e=document.createElement(\"div\");return e.innerHTML=n,t.appendChild(e.firstChild),t.setAttribute(\"data-vimeo-initialized\",\"true\"),t.querySelector(\"iframe\")}function E(i,e,t){var a=1<arguments.length&&void 0!==e?e:{},u=2<arguments.length?t:void 0;return new Promise(function(t,n){if(!l(i))throw new TypeError(\"\u201c\".concat(i,\"\u201d is not a vimeo.com url.\"));var e,r=\"https://vimeo.com/api/oembed.json?url=\".concat(encodeURIComponent(i));for(e in a)a.hasOwnProperty(e)&&(r+=\"&\".concat(e,\"=\").concat(encodeURIComponent(a[e])));var o=new(\"XDomainRequest\"in window?XDomainRequest:XMLHttpRequest);o.open(\"GET\",r,!0),o.onload=function(){if(404!==o.status)if(403!==o.status)try{var e=JSON.parse(o.responseText);if(403===e.domain_status_code)return k(e,u),void n(new Error(\"\u201c\".concat(i,\"\u201d is not embeddable.\")));t(e)}catch(e){n(e)}else n(new Error(\"\u201c\".concat(i,\"\u201d is not embeddable.\")));else n(new Error(\"\u201c\".concat(i,\"\u201d was not found.\")))},o.onerror=function(){var e=o.status?\" (\".concat(o.status,\")\"):\"\";n(new Error(\"There was an error fetching the embed code from Vimeo\".concat(e,\".\")))},o.send()})}function T(e){function n(e){\"console\"in window&&console.error&&console.error(\"There was an error creating an embed: \".concat(e))}e=0<arguments.length&&void 0!==e?e:document,e=[].slice.call(e.querySelectorAll(\"[data-vimeo-id], [data-vimeo-url]\"));e.forEach(function(t){try{if(null!==t.getAttribute(\"data-vimeo-defer\"))return;var e=b(t);E(u(e),e,t).then(function(e){return k(e,t)}).catch(n)}catch(e){n(e)}})}function P(e){if(\"string\"==typeof e)try{e=JSON.parse(e)}catch(e){return console.warn(e),{}}return e}function _(e,t,n){e.element.contentWindow&&e.element.contentWindow.postMessage&&(t={method:t},void 0!==n&&(t.value=n),8<=(n=parseFloat(navigator.userAgent.toLowerCase().replace(/^.*msie (\\d+).*$/,\"$1\")))&&n<10&&(t=JSON.stringify(t)),e.element.contentWindow.postMessage(t,e.origin))}function M(n,r){var t,e,o,i,a=[];(r=P(r)).event?(\"error\"===r.event&&y(n,r.data.method).forEach(function(e){var t=new Error(r.data.message);t.name=r.data.name,e.reject(t),g(n,r.data.method,e)}),a=y(n,\"event:\".concat(r.event)),t=r.data):r.method&&(e=n,o=r.method,(i=!((i=y(e,o)).length<1)&&(i=i.shift(),g(e,o,i),i))&&(a.push(i),t=r.value)),a.forEach(function(e){try{if(\"function\"==typeof e)return void e.call(n,t);e.resolve(t)}catch(e){}})}var N,F,x,C=new WeakMap,j=new WeakMap,A={},Player=function(){function Player(i){var e,a=this,t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,Player),window.jQuery&&i instanceof jQuery&&(1<i.length&&window.console&&console.warn&&console.warn(\"A jQuery object with multiple elements was passed, using the first element.\"),i=i[0]),\"undefined\"!=typeof document&&\"string\"==typeof i&&(i=document.getElementById(i)),e=i,!Boolean(e&&1===e.nodeType&&\"nodeName\"in e&&e.ownerDocument&&e.ownerDocument.defaultView))throw new TypeError(\"You must pass either a valid element or a valid id.\");if(\"IFRAME\"===i.nodeName||(r=i.querySelector(\"iframe\"))&&(i=r),\"IFRAME\"===i.nodeName&&!l(i.getAttribute(\"src\")||\"\"))throw new Error(\"The player element passed isn\u2019t a Vimeo embed.\");if(C.has(i))return C.get(i);this._window=i.ownerDocument.defaultView,this.element=i,this.origin=\"*\";var n,r=new m(function(r,o){var e;a._onMessage=function(e){if(l(e.origin)&&a.element.contentWindow===e.source){\"*\"===a.origin&&(a.origin=e.origin);var t=P(e.data);if(t&&\"error\"===t.event&&t.data&&\"ready\"===t.data.method){var n=new Error(t.data.message);return n.name=t.data.name,void o(n)}e=t&&\"ready\"===t.event,n=t&&\"ping\"===t.method;if(e||n)return a.element.setAttribute(\"data-ready\",\"true\"),void r();M(a,t)}},a._window.addEventListener(\"message\",a._onMessage),\"IFRAME\"!==a.element.nodeName&&E(u(e=b(i,t)),e,i).then(function(e){var t,n,r=k(e,i);return a.element=r,a._originalElement=i,t=i,n=r,r=v.get(t),v.set(n,r),v.delete(t),C.set(a.element,a),e}).catch(o)});return j.set(this,r),C.set(this.element,this),\"IFRAME\"===this.element.nodeName&&_(this,\"ping\"),A.isEnabled&&(n=function(){return A.exit()},this.fullscreenchangeHandler=function(){(A.isFullscreen?p:g)(a,\"event:exitFullscreen\",n),a.ready().then(function(){_(a,\"fullscreenchange\",A.isFullscreen)})},A.on(\"fullscreenchange\",this.fullscreenchangeHandler)),this}var e,t,n;return e=Player,(t=[{key:\"callMethod\",value:function(n){var r=this,o=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};return new m(function(e,t){return r.ready().then(function(){p(r,n,{resolve:e,reject:t}),_(r,n,o)}).catch(t)})}},{key:\"get\",value:function(n){var r=this;return new m(function(e,t){return n=i(n,\"get\"),r.ready().then(function(){p(r,n,{resolve:e,reject:t}),_(r,n)}).catch(t)})}},{key:\"set\",value:function(n,r){var o=this;return new m(function(e,t){if(n=i(n,\"set\"),null==r)throw new TypeError(\"There must be a value to set.\");return o.ready().then(function(){p(o,n,{resolve:e,reject:t}),_(o,n,r)}).catch(t)})}},{key:\"on\",value:function(e,t){if(!e)throw new TypeError(\"You must pass an event name.\");if(!t)throw new TypeError(\"You must pass a callback function.\");if(\"function\"!=typeof t)throw new TypeError(\"The callback must be a function.\");0===y(this,\"event:\".concat(e)).length&&this.callMethod(\"addEventListener\",e).catch(function(){}),p(this,\"event:\".concat(e),t)}},{key:\"off\",value:function(e,t){if(!e)throw new TypeError(\"You must pass an event name.\");if(t&&\"function\"!=typeof t)throw new TypeError(\"The callback must be a function.\");g(this,\"event:\".concat(e),t)&&this.callMethod(\"removeEventListener\",e).catch(function(e){})}},{key:\"loadVideo\",value:function(e){return this.callMethod(\"loadVideo\",e)}},{key:\"ready\",value:function(){var e=j.get(this)||new m(function(e,t){t(new Error(\"Unknown player. Probably unloaded.\"))});return m.resolve(e)}},{key:\"addCuePoint\",value:function(e){return this.callMethod(\"addCuePoint\",{time:e,data:1<arguments.length&&void 0!==arguments[1]?arguments[1]:{}})}},{key:\"removeCuePoint\",value:function(e){return this.callMethod(\"removeCuePoint\",e)}},{key:\"enableTextTrack\",value:function(e,t){if(!e)throw new TypeError(\"You must pass a language.\");return this.callMethod(\"enableTextTrack\",{language:e,kind:t})}},{key:\"disableTextTrack\",value:function(){return this.callMethod(\"disableTextTrack\")}},{key:\"pause\",value:function(){return this.callMethod(\"pause\")}},{key:\"play\",value:function(){return this.callMethod(\"play\")}},{key:\"requestFullscreen\",value:function(){return A.isEnabled?A.request(this.element):this.callMethod(\"requestFullscreen\")}},{key:\"exitFullscreen\",value:function(){return A.isEnabled?A.exit():this.callMethod(\"exitFullscreen\")}},{key:\"getFullscreen\",value:function(){return A.isEnabled?m.resolve(A.isFullscreen):this.get(\"fullscreen\")}},{key:\"requestPictureInPicture\",value:function(){return this.callMethod(\"requestPictureInPicture\")}},{key:\"exitPictureInPicture\",value:function(){return this.callMethod(\"exitPictureInPicture\")}},{key:\"getPictureInPicture\",value:function(){return this.get(\"pictureInPicture\")}},{key:\"unload\",value:function(){return this.callMethod(\"unload\")}},{key:\"destroy\",value:function(){var n=this;return new m(function(e){var t;j.delete(n),C.delete(n.element),n._originalElement&&(C.delete(n._originalElement),n._originalElement.removeAttribute(\"data-vimeo-initialized\")),n.element&&\"IFRAME\"===n.element.nodeName&&n.element.parentNode&&(n.element.parentNode.parentNode&&n._originalElement&&n._originalElement!==n.element.parentNode?n.element.parentNode.parentNode.removeChild(n.element.parentNode):n.element.parentNode.removeChild(n.element)),n.element&&\"DIV\"===n.element.nodeName&&n.element.parentNode&&(n.element.removeAttribute(\"data-vimeo-initialized\"),(t=n.element.querySelector(\"iframe\"))&&t.parentNode&&(t.parentNode.parentNode&&n._originalElement&&n._originalElement!==t.parentNode?t.parentNode.parentNode.removeChild(t.parentNode):t.parentNode.removeChild(t))),n._window.removeEventListener(\"message\",n._onMessage),A.isEnabled&&A.off(\"fullscreenchange\",n.fullscreenchangeHandler),e()})}},{key:\"getAutopause\",value:function(){return this.get(\"autopause\")}},{key:\"setAutopause\",value:function(e){return this.set(\"autopause\",e)}},{key:\"getBuffered\",value:function(){return this.get(\"buffered\")}},{key:\"getCameraProps\",value:function(){return this.get(\"cameraProps\")}},{key:\"setCameraProps\",value:function(e){return this.set(\"cameraProps\",e)}},{key:\"getChapters\",value:function(){return this.get(\"chapters\")}},{key:\"getCurrentChapter\",value:function(){return this.get(\"currentChapter\")}},{key:\"getColor\",value:function(){return this.get(\"color\")}},{key:\"setColor\",value:function(e){return this.set(\"color\",e)}},{key:\"getCuePoints\",value:function(){return this.get(\"cuePoints\")}},{key:\"getCurrentTime\",value:function(){return this.get(\"currentTime\")}},{key:\"setCurrentTime\",value:function(e){return this.set(\"currentTime\",e)}},{key:\"getDuration\",value:function(){return this.get(\"duration\")}},{key:\"getEnded\",value:function(){return this.get(\"ended\")}},{key:\"getLoop\",value:function(){return this.get(\"loop\")}},{key:\"setLoop\",value:function(e){return this.set(\"loop\",e)}},{key:\"setMuted\",value:function(e){return this.set(\"muted\",e)}},{key:\"getMuted\",value:function(){return this.get(\"muted\")}},{key:\"getPaused\",value:function(){return this.get(\"paused\")}},{key:\"getPlaybackRate\",value:function(){return this.get(\"playbackRate\")}},{key:\"setPlaybackRate\",value:function(e){return this.set(\"playbackRate\",e)}},{key:\"getPlayed\",value:function(){return this.get(\"played\")}},{key:\"getQualities\",value:function(){return this.get(\"qualities\")}},{key:\"getQuality\",value:function(){return this.get(\"quality\")}},{key:\"setQuality\",value:function(e){return this.set(\"quality\",e)}},{key:\"getSeekable\",value:function(){return this.get(\"seekable\")}},{key:\"getSeeking\",value:function(){return this.get(\"seeking\")}},{key:\"getTextTracks\",value:function(){return this.get(\"textTracks\")}},{key:\"getVideoEmbedCode\",value:function(){return this.get(\"videoEmbedCode\")}},{key:\"getVideoId\",value:function(){return this.get(\"videoId\")}},{key:\"getVideoTitle\",value:function(){return this.get(\"videoTitle\")}},{key:\"getVideoWidth\",value:function(){return this.get(\"videoWidth\")}},{key:\"getVideoHeight\",value:function(){return this.get(\"videoHeight\")}},{key:\"getVideoUrl\",value:function(){return this.get(\"videoUrl\")}},{key:\"getVolume\",value:function(){return this.get(\"volume\")}},{key:\"setVolume\",value:function(e){return this.set(\"volume\",e)}}])&&r(e.prototype,t),n&&r(e,n),Player}();return e||(N=function(){for(var e,t=[[\"requestFullscreen\",\"exitFullscreen\",\"fullscreenElement\",\"fullscreenEnabled\",\"fullscreenchange\",\"fullscreenerror\"],[\"webkitRequestFullscreen\",\"webkitExitFullscreen\",\"webkitFullscreenElement\",\"webkitFullscreenEnabled\",\"webkitfullscreenchange\",\"webkitfullscreenerror\"],[\"webkitRequestFullScreen\",\"webkitCancelFullScreen\",\"webkitCurrentFullScreenElement\",\"webkitCancelFullScreen\",\"webkitfullscreenchange\",\"webkitfullscreenerror\"],[\"mozRequestFullScreen\",\"mozCancelFullScreen\",\"mozFullScreenElement\",\"mozFullScreenEnabled\",\"mozfullscreenchange\",\"mozfullscreenerror\"],[\"msRequestFullscreen\",\"msExitFullscreen\",\"msFullscreenElement\",\"msFullscreenEnabled\",\"MSFullscreenChange\",\"MSFullscreenError\"]],n=0,r=t.length,o={};n<r;n++)if((e=t[n])&&e[1]in document){for(n=0;n<e.length;n++)o[t[0][n]]=e[n];return o}return!1}(),F={fullscreenchange:N.fullscreenchange,fullscreenerror:N.fullscreenerror},x={request:function(o){return new Promise(function(e,t){function n(){x.off(\"fullscreenchange\",n),e()}x.on(\"fullscreenchange\",n);var r=(o=o||document.documentElement)[N.requestFullscreen]();r instanceof Promise&&r.then(n).catch(t)})},exit:function(){return new Promise(function(t,e){var n,r;x.isFullscreen?(n=function e(){x.off(\"fullscreenchange\",e),t()},x.on(\"fullscreenchange\",n),(r=document[N.exitFullscreen]())instanceof Promise&&r.then(n).catch(e)):t()})},on:function(e,t){e=F[e];e&&document.addEventListener(e,t)},off:function(e,t){e=F[e];e&&document.removeEventListener(e,t)}},Object.defineProperties(x,{isFullscreen:{get:function(){return Boolean(document[N.fullscreenElement])}},element:{enumerable:!0,get:function(){return document[N.fullscreenElement]}},isEnabled:{enumerable:!0,get:function(){return Boolean(document[N.fullscreenEnabled])}}}),A=x,T(),function(e){var r=0<arguments.length&&void 0!==e?e:document;window.VimeoPlayerResizeEmbeds_||(window.VimeoPlayerResizeEmbeds_=!0,window.addEventListener(\"message\",function(e){if(l(e.origin)&&e.data&&\"spacechange\"===e.data.event)for(var t=r.querySelectorAll(\"iframe\"),n=0;n<t.length;n++)if(t[n].contentWindow===e.source){t[n].parentElement.style.paddingBottom=\"\".concat(e.data.data[0].bottom,\"px\");break}}))}()),Player});\n","vimeo/vimeo-wrapper.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'vimeo'\n], function (Player) {\n    'use strict';\n\n    window.Vimeo = window.Vimeo || {\n        'Player': Player\n    };\n});\n"}
}});
